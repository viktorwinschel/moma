var documenterSearchIndex = {"docs":
[{"location":"error_handling.html#Error-Handling","page":"Error Handling","title":"Error Handling","text":"","category":"section"},{"location":"error_handling.html","page":"Error Handling","title":"Error Handling","text":"The framework includes comprehensive error checking to ensure categorical laws are maintained:","category":"page"},{"location":"error_handling.html","page":"Error Handling","title":"Error Handling","text":"using Moma\n\n# Declare global variables\nglobal incompatible_caught = false\nglobal invalid_pattern_caught = false\nglobal invalid_binding_caught = false\n\n# Create some basic objects and morphisms for testing\nA = Object(:A, 1)\nB = Object(:B, 2)\nC = Object(:C, 3)\nvalid_f = Morphism(A, B, x -> x + 1, :valid_f)\nvalid_g = Morphism(B, C, x -> x * 2, :valid_g)\ncat = Category([A, B, C], [valid_f, valid_g], :TestCat)\n\n# Test object properties\n@assert A.id == :A && A.data == 1\n@assert B.id == :B && B.data == 2\n@assert C.id == :C && C.data == 3\n\n# Test morphism properties\n@assert valid_f.source == A && valid_f.target == B\n@assert valid_g.source == B && valid_g.target == C\n@assert valid_f.id == :valid_f && valid_g.id == :valid_g\n@assert valid_f.map(1) == 2  # Test function mapping\n@assert valid_g.map(2) == 4  # Test function mapping\n\n# Test category properties\n@assert cat.id == :TestCat\n@assert length(cat.objects) == 3\n@assert length(cat.morphisms) == 2\n@assert A in cat.objects && B in cat.objects && C in cat.objects\n@assert valid_f in cat.morphisms && valid_g in cat.morphisms\n\n# Test valid composition works\ncomposed = compose(valid_f, valid_g)\n@assert composed.source == A\n@assert composed.target == C\n@assert composed.map(1) == 4  # (1 + 1) * 2\n@assert composed.id == :valid_f_valid_g\n\n# Test identity morphism\nid_A = identity(A)\n@assert id_A.id == A.id  # Identity morphism name\n\n# Test incompatible morphism composition\nf = Morphism(A, B, x -> x, :f)\ng = Morphism(C, A, x -> x, :g)\ntry\n    compose(f, g)\ncatch e\n    global incompatible_caught = true\n    @assert e isa ErrorException\n    @assert e.msg == \"Morphisms are not composable\"\nend\n@assert incompatible_caught\n\n# Test invalid pattern creation\ntry\n    X = Object(:X, 0)  # Object not in category\n    create_pattern(cat, [X], Morphism[])\ncatch e\n    global invalid_pattern_caught = true\n    @assert e isa ErrorException\n    @assert occursin(\"Objects must belong to the category\", e.msg)\nend\n@assert invalid_pattern_caught\n\n# Test valid pattern creation\nvalid_pattern = create_pattern(cat, [A, B], [valid_f])\n@assert valid_pattern.category == cat\n@assert length(valid_pattern.objects) == 2\n@assert length(valid_pattern.morphisms) == 1\n@assert A in valid_pattern.objects && B in valid_pattern.objects\n@assert valid_f in valid_pattern.morphisms\n@assert valid_pattern.id == Symbol(\"pattern_TestCat\")\n\n# Test invalid colimit binding\ntry\n    # Create a valid pattern first\n    bad_obj = Object(:bad, 0)\n    empty_bindings = Dict{Object{Int64},Morphism{Int64,Int64}}()\n    check_binding(bad_obj, empty_bindings, valid_pattern)\ncatch e\n    global invalid_binding_caught = true\n    @assert e isa ErrorException\n    @assert occursin(\"Missing bindings\", e.msg)\nend\n@assert invalid_binding_caught\n\n# Test morphism category membership\n@assert is_morphism_in_category(valid_f, cat)\n@assert is_morphism_in_category(valid_g, cat)\n@assert !is_morphism_in_category(Morphism(A, C, x -> x * 3, :h), cat)  # Non-member morphism","category":"page"},{"location":"error_handling.html#Self-Healing-Systems-in-MES-and-Julia","page":"Error Handling","title":"Self-Healing Systems in MES and Julia","text":"","category":"section"},{"location":"error_handling.html","page":"Error Handling","title":"Error Handling","text":"Memory Evolutive Systems (MES) introduce the concept of self-healing through their hierarchical organization and co-regulators. This concept can be implemented in Julia using its powerful error handling mechanisms. Here's how we can connect these ideas:","category":"page"},{"location":"error_handling.html#MES-Self-Healing-Concepts","page":"Error Handling","title":"MES Self-Healing Concepts","text":"","category":"section"},{"location":"error_handling.html","page":"Error Handling","title":"Error Handling","text":"Hierarchical Organization: MES systems are organized in levels, where each level can handle errors at its own scale\nCo-regulators: These are specialized subsystems that can detect and respond to errors\nMemory Links: Connections between different parts of the system that can be used for error recovery\nTime Scales: Different levels operate at different time scales, allowing for layered error handling","category":"page"},{"location":"error_handling.html#Implementation-in-Julia","page":"Error Handling","title":"Implementation in Julia","text":"","category":"section"},{"location":"error_handling.html","page":"Error Handling","title":"Error Handling","text":"We can (have not yet) implement these concepts using Julia's error handling mechanisms:","category":"page"},{"location":"error_handling.html","page":"Error Handling","title":"Error Handling","text":"# Example of hierarchical error handling inspired by MES\nstruct SystemLevel\n    name::Symbol\n    co_regulators::Vector{Function}\n    memory_links::Dict{Symbol, Any}\n    time_scale::Float64\nend\n\n# Co-regulator function that can detect and handle errors\nfunction create_co_regulator(level::SystemLevel, error_type::Type)\n    return function handle_error(err::error_type)\n        # Log the error at this level\n        @info \"Error detected at level $(level.name)\" error=err\n        \n        # Try to recover using memory links\n        for (link_name, link_data) in level.memory_links\n            try\n                # Attempt recovery using stored information\n                recover_from_memory(err, link_data)\n                return true\n            catch e\n                @warn \"Recovery attempt failed for link $link_name\" error=e\n            end\n        end\n        \n        # If recovery fails, propagate to next level\n        rethrow(err)\n    end\nend\n\n# Example usage\nfunction setup_hierarchical_system()\n    # Create system levels with different time scales\n    low_level = SystemLevel(:low, [], Dict(), 0.1)  # Fast response\n    mid_level = SystemLevel(:mid, [], Dict(), 1.0)  # Medium response\n    high_level = SystemLevel(:high, [], Dict(), 10.0)  # Slow response\n    \n    # Add co-regulators for different error types\n    push!(low_level.co_regulators, create_co_regulator(low_level, ArgumentError))\n    push!(mid_level.co_regulators, create_co_regulator(mid_level, MethodError))\n    push!(high_level.co_regulators, create_co_regulator(high_level, ErrorException))\n    \n    return [low_level, mid_level, high_level]\nend\n\n# Example of using the hierarchical system\nfunction process_with_self_healing(data)\n    system = setup_hierarchical_system()\n    \n    try\n        # Attempt processing at lowest level\n        result = process_data(data)\n        return result\n    catch err\n        # Try each level's co-regulators\n        for level in system\n            for co_regulator in level.co_regulators\n                try\n                    return co_regulator(err)\n                catch e\n                    continue  # Try next co-regulator\n                end\n            end\n        end\n        # If all recovery attempts fail, propagate error\n        rethrow(err)\n    end\nend","category":"page"},{"location":"error_handling.html#Key-Features-of-This-Implementation","page":"Error Handling","title":"Key Features of This Implementation","text":"","category":"section"},{"location":"error_handling.html","page":"Error Handling","title":"Error Handling","text":"Layered Error Handling: Each system level can handle errors at its own time scale\nMemory-Based Recovery: Uses stored information (memory links) to attempt recovery\nCo-regulator Pattern: Specialized handlers for different types of errors\nGraceful Degradation: System can fall back to simpler modes when errors occur\nError Propagation: Errors can move up the hierarchy if they can't be handled at the current level","category":"page"},{"location":"error_handling.html#Best-Practices","page":"Error Handling","title":"Best Practices","text":"","category":"section"},{"location":"error_handling.html","page":"Error Handling","title":"Error Handling","text":"Define Clear Error Types: Create specific error types for different failure modes\nImplement Recovery Strategies: Each co-regulator should have specific recovery procedures\nMaintain State: Use memory links to store recovery-relevant information\nMonitor and Log: Track error patterns and recovery attempts\nTime-Aware Handling: Consider the time scale of each level when implementing recovery","category":"page"},{"location":"error_handling.html","page":"Error Handling","title":"Error Handling","text":"This approach combines the theoretical framework of MES with Julia's practical error handling capabilities, creating robust, self-healing systems that can adapt to and recover from various types of failures.","category":"page"},{"location":"categories.html#Category-Theory","page":"Categories","title":"Category Theory","text":"","category":"section"},{"location":"categories.html","page":"Categories","title":"Categories","text":"This section provides a mathematical introduction to the category theory concepts implemented in MoMa.","category":"page"},{"location":"categories.html#Categories","page":"Categories","title":"Categories","text":"","category":"section"},{"location":"categories.html#Mathematical-Definition","page":"Categories","title":"Mathematical Definition","text":"","category":"section"},{"location":"categories.html","page":"Categories","title":"Categories","text":"A category mathcalC consists of:","category":"page"},{"location":"categories.html","page":"Categories","title":"Categories","text":"A collection of objects textOb(mathcalC)\nA collection of morphisms textHom(mathcalC), where each morphism f A to B has a source A and target B\nFor each object A, an identity morphism textid_A A to A\nA composition operation circ textHom(BC) times textHom(AB) to textHom(AC) that satisfies:\nAssociativity: (h circ g) circ f = h circ (g circ f) forall f A to B g B to C h C to D\nIdentity: f circ textid_A = f = textid_B circ f forall f A to B","category":"page"},{"location":"categories.html","page":"Categories","title":"Categories","text":"For a detailed theoretical background on categories, see MES23: Categories and Functors.","category":"page"},{"location":"categories.html","page":"Categories","title":"Categories","text":"beginCD\nA f B g C \nVtextid_AVV Vtextid_BVV Vtextid_CVV \nA f B g C\nendCD","category":"page"},{"location":"categories.html#Implementation","page":"Categories","title":"Implementation","text":"","category":"section"},{"location":"categories.html","page":"Categories","title":"Categories","text":"Objects, Morphisms, and Category are implemented in the Moma.Categories module as:","category":"page"},{"location":"categories.html","page":"Categories","title":"Categories","text":"Object\nMorphism\nCategory","category":"page"},{"location":"categories.html","page":"Categories","title":"Categories","text":"# Implementation in Categories.jl\nstruct Object{T}\n    name::Symbol\n    data::T\nend\n\nstruct Morphism{S,T}\n    source::Object{S}\n    target::Object{T}\n    map::Function\n    name::Symbol\nend\n\nstruct Category\n    objects::Vector{Object}\n    morphisms::Vector{Morphism}\n    name::Symbol\nend","category":"page"},{"location":"categories.html","page":"Categories","title":"Categories","text":"For comprehensive tests of these implementations, see the test files in the repository.","category":"page"},{"location":"categories.html#Examples","page":"Categories","title":"Examples","text":"","category":"section"},{"location":"categories.html","page":"Categories","title":"Categories","text":"The following examples demonstrate the basic usage with the helper functions implemented in the Moma.Categories module as:","category":"page"},{"location":"categories.html","page":"Categories","title":"Categories","text":"identity\ncompose","category":"page"},{"location":"categories.html","page":"Categories","title":"Categories","text":"using Moma\n\n# Test Object creation\nobj1 = Object(:A, \"data1\")\nobj2 = Object(:B, \"data2\")\nobj3 = Object(:C, \"data3\")\n@assert obj1.id == :A && obj1.data == \"data1\"\n@assert obj2.id == :B && obj2.data == \"data2\"\n@assert obj3.id == :C && obj3.data == \"data3\"\n\n# Test Morphism creation and composition\nm1 = Morphism(obj1, obj2, x -> uppercase(x), :m1)\nm2 = Morphism(obj2, obj3, x -> x * \"!\", :m2)\n@assert m1.source == obj1 && m1.target == obj2\n@assert m2.source == obj2 && m2.target == obj3\n@assert m1.name == :m1\n@assert m2.name == :m2\n@assert m1.map(\"test\") == \"TEST\"\n@assert m2.map(\"test\") == \"test!\"\n\n# Test composition\nm3 = compose(m1, m2)\n@assert m3.source == obj1 &&\n    m3.target == obj3 &&\n    m3.map(\"test\") == \"TEST!\"\n@assert m3.name == :m1_m2  # Check composed morphism name\n\n# Test identity morphism\nid_morph = Moma.identity(obj1)\n@assert id_morph.source == obj1 &&\n    id_morph.target == obj1 &&\n    id_morph.map(\"test\") == \"test\"\n@assert id_morph.name == :id_A  # Check identity morphism name\n\n# Test Category creation and membership\ncat = Category([obj1, obj2, obj3], [m1, m2, m3], :TestCat)\n@assert length(cat.objects) == 3 &&\n    length(cat.morphisms) == 3 &&\n    is_morphism_in_category(m1, cat)\n@assert cat.name == :TestCat\n@assert obj1 in cat.objects\n@assert obj2 in cat.objects\n@assert obj3 in cat.objects\n@assert m1 in cat.morphisms\n@assert m2 in cat.morphisms\n@assert m3 in cat.morphisms\n\n# Test Pattern creation and validation\npattern = create_pattern(cat, [obj1, obj2], [m1])\n@assert length(pattern.objects) == 2 &&\n    length(pattern.morphisms) == 1 &&\n    pattern.category == cat\n@assert obj1 in pattern.objects\n@assert obj2 in pattern.objects\n@assert m1 in pattern.morphisms\n\n# Test binding checks\nbindings = Dict(\n    obj1 => Morphism(obj1, obj2, x -> uppercase(x), :bind1),\n    obj2 => Moma.identity(obj2)\n)\n@assert check_binding(obj2, bindings, pattern)\n@assert haskey(bindings, obj1)\n@assert haskey(bindings, obj2)\n@assert bindings[obj1].name == :bind1\n@assert bindings[obj2].name == :id_B","category":"page"},{"location":"categories.html","page":"Categories","title":"Categories","text":"For more complex examples and edge cases, see the test files in the repository.","category":"page"},{"location":"categories.html#Functors","page":"Categories","title":"Functors","text":"","category":"section"},{"location":"categories.html#Mathematical-Definition-2","page":"Categories","title":"Mathematical Definition","text":"","category":"section"},{"location":"categories.html","page":"Categories","title":"Categories","text":"A functor F mathcalC to mathcalD between categories consists of:","category":"page"},{"location":"categories.html","page":"Categories","title":"Categories","text":"An object mapping F_textob textOb(mathcalC) to textOb(mathcalD)\nA morphism mapping F_textmor textHom_mathcalC(AB) to textHom_mathcalD(F(A)F(B))","category":"page"},{"location":"categories.html","page":"Categories","title":"Categories","text":"beginCD\nmathcalC F mathcalD \nVtextid_mathcalCVV Vtextid_mathcalDVV \nmathcalC F mathcalD\nendCD","category":"page"},{"location":"categories.html","page":"Categories","title":"Categories","text":"For theoretical foundations and applications of functors in MES, see MES23: Functorial Evolution.","category":"page"},{"location":"categories.html#Implementation-2","page":"Categories","title":"Implementation","text":"","category":"section"},{"location":"categories.html","page":"Categories","title":"Categories","text":"Functors are implemented in the Moma.Categories module as:","category":"page"},{"location":"categories.html","page":"Categories","title":"Categories","text":"Functor","category":"page"},{"location":"categories.html","page":"Categories","title":"Categories","text":"# Implementation in Categories.jl\nstruct Functor\n    source::Category\n    target::Category\n    object_map::Dict{Object,Object}\n    morphism_map::Dict{Morphism,Morphism}\n    name::Symbol\nend","category":"page"},{"location":"categories.html#Examples-2","page":"Categories","title":"Examples","text":"","category":"section"},{"location":"categories.html","page":"Categories","title":"Categories","text":"The following examples demonstrate functor creation and verification:","category":"page"},{"location":"categories.html","page":"Categories","title":"Categories","text":"using Moma\n\n# Create source and target categories\nsrc_cat = Category([obj1, obj2], [m1], :source)\ntgt_cat = Category([obj3], [identity(obj3)], :target)\n\n# Define functor mappings\nobj_map = Dict(obj1 => obj3, obj2 => obj3)\nmorph_map = Dict(m1 => identity(obj3))\n\n# Create functor\nF = Functor(src_cat, tgt_cat, obj_map, morph_map, :F)","category":"page"},{"location":"categories.html#Natural-Transformations","page":"Categories","title":"Natural Transformations","text":"","category":"section"},{"location":"categories.html#Mathematical-Definition-3","page":"Categories","title":"Mathematical Definition","text":"","category":"section"},{"location":"categories.html","page":"Categories","title":"Categories","text":"Given functors FG mathcalC to mathcalD, a natural transformation eta F Rightarrow G consists of:","category":"page"},{"location":"categories.html","page":"Categories","title":"Categories","text":"A family of morphisms eta_A F(A) to G(A) forall A in textOb(mathcalC)","category":"page"},{"location":"categories.html","page":"Categories","title":"Categories","text":"For the role of natural transformations in MES, see MES07: Natural Transformations and System Evolution.","category":"page"},{"location":"categories.html","page":"Categories","title":"Categories","text":"Such that the naturality condition holds:","category":"page"},{"location":"categories.html","page":"Categories","title":"Categories","text":"G(f) circ eta_A = eta_B circ F(f) forall f A to B in mathcalC","category":"page"},{"location":"categories.html","page":"Categories","title":"Categories","text":"beginCD\nF(A) F(f) F(B) \nVeta_AVV Veta_BVV \nG(A) G(f) G(B)\nendCD","category":"page"},{"location":"categories.html#Implementation-3","page":"Categories","title":"Implementation","text":"","category":"section"},{"location":"categories.html","page":"Categories","title":"Categories","text":"Natural transformations are implemented in the Moma.Categories module as:","category":"page"},{"location":"categories.html","page":"Categories","title":"Categories","text":"NaturalTransformation","category":"page"},{"location":"categories.html","page":"Categories","title":"Categories","text":"# Implementation in Categories.jl\nstruct NaturalTransformation\n    source::Functor\n    target::Functor\n    components::Dict{Object,Morphism}\n    name::Symbol\nend","category":"page"},{"location":"categories.html#Examples-3","page":"Categories","title":"Examples","text":"","category":"section"},{"location":"categories.html","page":"Categories","title":"Categories","text":"The following examples demonstrate natural transformation creation and verification:","category":"page"},{"location":"categories.html","page":"Categories","title":"Categories","text":"using Moma\n\n# Create components for natural transformation\ncomponents = Dict(\n    obj1 => Morphism(F.object_map[obj1], G.object_map[obj1], x -> x, :eta_A),\n    obj2 => Morphism(F.object_map[obj2], G.object_map[obj2], x -> x, :eta_B)\n)\n\n# Create natural transformation\neta = NaturalTransformation(F, G, components, :eta)","category":"page"},{"location":"categories.html#Patterns-and-Colimits","page":"Categories","title":"Patterns and Colimits","text":"","category":"section"},{"location":"categories.html#Mathematical-Definition-4","page":"Categories","title":"Mathematical Definition","text":"","category":"section"},{"location":"categories.html","page":"Categories","title":"Categories","text":"A pattern P in a category mathcalC consists of:","category":"page"},{"location":"categories.html","page":"Categories","title":"Categories","text":"A diagram D mathcalJ to mathcalC where mathcalJ is a small category\nObjects D(j) for each j in textOb(mathcalJ)\nMorphisms D(f) D(j) to D(k) for each f j to k in mathcalJ","category":"page"},{"location":"categories.html","page":"Categories","title":"Categories","text":"For the significance of patterns and colimits in complex systems, see MES23: Patterns and Complexity.","category":"page"},{"location":"categories.html","page":"Categories","title":"Categories","text":"A colimit of pattern P consists of:","category":"page"},{"location":"categories.html","page":"Categories","title":"Categories","text":"An object textcolim(P)\nA family of morphisms iota_j D(j) to textcolim(P)","category":"page"},{"location":"categories.html","page":"Categories","title":"Categories","text":"Such that:","category":"page"},{"location":"categories.html","page":"Categories","title":"Categories","text":"iota_k circ D(f) = iota_j for all f j to k in mathcalJ\nUniversal property: For any other cocone (C (gamma_j)_j in mathcalJ), there exists a unique u textcolim(P) to C such that u circ iota_j = gamma_j","category":"page"},{"location":"categories.html","page":"Categories","title":"Categories","text":"beginCD\nD(j) D(f) D(k) \nViota_jVV VViota_kV \ntextcolim(P) = textcolim(P)\nendCD","category":"page"},{"location":"categories.html#Implementation-4","page":"Categories","title":"Implementation","text":"","category":"section"},{"location":"categories.html","page":"Categories","title":"Categories","text":"Patterns and colimits are implemented in the Moma.Categories module as:","category":"page"},{"location":"categories.html","page":"Categories","title":"Categories","text":"Pattern","category":"page"},{"location":"categories.html","page":"Categories","title":"Categories","text":"# Implementation in Categories.jl\nstruct Pattern\n    category::Category\n    objects::Vector{Object}\n    morphisms::Vector{Morphism}\n    name::Symbol\nend","category":"page"},{"location":"categories.html","page":"Categories","title":"Categories","text":"The module provides functions for working with patterns and colimits:","category":"page"},{"location":"categories.html","page":"Categories","title":"Categories","text":"create_pattern: Creates a pattern from objects and morphisms\ncheck_binding: Verifies if an object forms a colimit for a pattern\nfind_colimit: Computes the colimit of a pattern","category":"page"},{"location":"categories.html#Examples-4","page":"Categories","title":"Examples","text":"","category":"section"},{"location":"categories.html","page":"Categories","title":"Categories","text":"The following examples demonstrate pattern creation and colimit construction:","category":"page"},{"location":"categories.html","page":"Categories","title":"Categories","text":"using Moma\n\n# Create simple objects and morphisms\na = Object(:A, 1)\nb = Object(:B, 2)\nf = Morphism(a, b, x -> x + 1, :f)\n@assert a.id == :A && a.data == 1\n@assert b.id == :B && b.data == 2\n@assert f.name == :f\n@assert f.map(1) == 2\n\n# Create category and pattern\ncat = Category([a, b], [f], :ColimitTest)\npat = create_pattern(cat, [a, b], [f])\n@assert cat.name == :ColimitTest\n@assert length(cat.objects) == 2\n@assert length(cat.morphisms) == 1\n@assert length(pat.objects) == 2\n@assert length(pat.morphisms) == 1\n\n# Find colimit\ncolimit_obj, bindings = find_colimit(pat)\n\n# Test colimit properties\n@assert colimit_obj.data == [1, 2]  # Combined data\n@assert haskey(bindings, a)\n@assert haskey(bindings, b)\n@assert bindings[a].target == colimit_obj\n@assert bindings[b].target == colimit_obj\n@assert check_binding(colimit_obj, bindings, pat)\n@assert colimit_obj.id == :colimit  # Check colimit object name\n\n# Test colimit universal property\n@assert bindings[a].map(a.data) == [1, 2]\n@assert bindings[b].map(b.data) == [1, 2]\n@assert bindings[a].name == :injection_A  # Check injection morphism names\n@assert bindings[b].name == :injection_B","category":"page"},{"location":"categories.html#Memory-Evolutive-Systems","page":"Categories","title":"Memory Evolutive Systems","text":"","category":"section"},{"location":"categories.html#Mathematical-Definition-5","page":"Categories","title":"Mathematical Definition","text":"","category":"section"},{"location":"categories.html","page":"Categories","title":"Categories","text":"A Memory Evolutive System (MES) consists of:","category":"page"},{"location":"categories.html","page":"Categories","title":"Categories","text":"A category mathcalC of components and their relationships\nA hierarchy of complexity levels through colimit formation\nA dynamic structure through time evolution","category":"page"},{"location":"categories.html","page":"Categories","title":"Categories","text":"For a comprehensive introduction to MES, see MES07: Introduction and MES23: Memory Evolutive Systems.","category":"page"},{"location":"categories.html","page":"Categories","title":"Categories","text":"The key operations include:","category":"page"},{"location":"categories.html","page":"Categories","title":"Categories","text":"Pattern formation through selection of objects and morphisms\nColimit computation for complex component formation\nTemporal evolution through functorial transitions","category":"page"},{"location":"categories.html#Implementation-5","page":"Categories","title":"Implementation","text":"","category":"section"},{"location":"categories.html","page":"Categories","title":"Categories","text":"The MES implementation builds upon the previous structures:","category":"page"},{"location":"categories.html","page":"Categories","title":"Categories","text":"Uses categories to represent system state\nEmploys patterns to identify meaningful subsystems\nComputes colimits to form higher-order components\nTracks temporal evolution through category morphisms","category":"page"},{"location":"categories.html","page":"Categories","title":"Categories","text":"For example, creating a basic hierarchical structure:","category":"page"},{"location":"categories.html","page":"Categories","title":"Categories","text":"# Create base level components\nA = Object(:A, \"base_component_1\")\nB = Object(:B, \"base_component_2\")\nf = Morphism(A, B, x -> process(x), :f)\n\n# Form a pattern\npattern = Pattern(category, [A, B], [f])\n\n# Compute colimit for higher-order component\ncolimit = find_colimit(pattern)","category":"page"},{"location":"categories.html#Examples-5","page":"Categories","title":"Examples","text":"","category":"section"},{"location":"categories.html","page":"Categories","title":"Categories","text":"using Moma\n\n# Create base level components\nneuron1 = Object(:N1, \"neuron_data_1\")\nneuron2 = Object(:N2, \"neuron_data_2\")\nsynapse = Morphism(neuron1, neuron2, \n                  x -> \"synapse_\" * x, :syn)\n@assert neuron1.id == :N1 && neuron1.data == \"neuron_data_1\"\n@assert neuron2.id == :N2 && neuron2.data == \"neuron_data_2\"\n@assert synapse.name == :syn\n@assert synapse.map(\"test\") == \"synapse_test\"\n\n# Create neural pattern\nneural_cat = Category([neuron1, neuron2], [synapse], :neural)\npattern = create_pattern(neural_cat, [neuron1, neuron2], [synapse])\n@assert neural_cat.name == :neural\n@assert length(neural_cat.objects) == 2\n@assert length(neural_cat.morphisms) == 1\n@assert length(pattern.objects) == 2\n@assert length(pattern.morphisms) == 1\n\n# Form higher-order component (neural assembly)\nassembly, bindings = find_colimit(pattern)\n\n# Verify the formation\n@assert check_binding(assembly, bindings, pattern)\n@assert assembly.id == :colimit  # Check assembly name\n@assert haskey(bindings, neuron1)\n@assert haskey(bindings, neuron2)\n@assert bindings[neuron1].name == :injection_N1  # Check injection morphism names\n@assert bindings[neuron2].name == :injection_N2","category":"page"},{"location":"categories.html#Further-Reading","page":"Categories","title":"Further Reading","text":"","category":"section"},{"location":"categories.html","page":"Categories","title":"Categories","text":"For more detailed mathematical background and applications:","category":"page"},{"location":"categories.html","page":"Categories","title":"Categories","text":"MES23: Newer developments in Memory Evolutive Systems on human-machine interaction\nMES07: Memory Evolutive Systems (MES)\nMoMa25 Monetary Macro Accounting (MoMa) Theory (MoMaT)\nPapers: Complete list of related publications and theoretical background","category":"page"},{"location":"state_space_models.html#State-Space-Model","page":"State Space Models","title":"State Space Model","text":"","category":"section"},{"location":"state_space_models.html","page":"State Space Models","title":"State Space Models","text":"We switch from functions to functors for state transitions, states become categories, and use it for a monetary macro accounting (MoMa) then MES, ERP and EcRP.","category":"page"},{"location":"state_space_models.html","page":"State Space Models","title":"State Space Models","text":"A usual way to model dynamics of economic systems are state space models. We will see now how to model them in MES to use them for a simple economics approach to model the MoMa phenomenon of money. This is the tranditional way we have implemented a first version of MoMa25 in simple Julia in file momascf_v02_en.jl. It is a deterministic nonlinear model but still reduced form model. Reduced form model is a economists way to say its a Markov decision process not even forward looking which would an economist call structural model. These forward lookings models can be modeled as Open Games but actually economic models should become MES systems where Open Games are coregulators.","category":"page"},{"location":"state_space_models.html#State-Space-Model-as-MES","page":"State Space Models","title":"State Space Model as MES","text":"","category":"section"},{"location":"state_space_models.html","page":"State Space Models","title":"State Space Models","text":"Traditional state space models represent system dynamics as simple vector-valued functions mapping states to states. While this approach is intuitive and computationally efficient, it has several limitations:","category":"page"},{"location":"state_space_models.html","page":"State Space Models","title":"State Space Models","text":"Limited Expressiveness: Traditional state space models can only represent direct state-to-state mappings, making it difficult to model:\nComplex hierarchical relationships\nMultiple time scales\nEmergent properties\nMemory-dependent dynamics\nNo Built-in Structure: Standard state space models don't naturally capture:\nSystem composition\nComponent relationships\nTemporal dependencies\nMemory formation\nRigid Evolution: Conventional models often struggle with:\nAdaptive behavior\nSystem reconfiguration\nEmergent complexity\nMulti-level interactions","category":"page"},{"location":"state_space_models.html","page":"State Space Models","title":"State Space Models","text":"The Memory Evolutive Systems (MES) framework, built on category theory, addresses these limitations by:","category":"page"},{"location":"state_space_models.html","page":"State Space Models","title":"State Space Models","text":"Rich Mathematical Structure:\nObjects represent system components\nMorphisms capture relationships and transformations\nCategories organize system structure\nFunctors model system evolution\nBuilt-in Memory:\nExplicit representation of past states\nTemporal ordering through categorical structure\nMemory formation through colimits\nHistorical dependencies\nFlexible Composition:\nHierarchical organization\nComponent relationships\nSystem decomposition\nEmergent properties\nNatural Evolution:\nFunctorial dynamics\nAdaptive behavior\nSystem reconfiguration\nMulti-level interactions","category":"page"},{"location":"state_space_models.html","page":"State Space Models","title":"State Space Models","text":"The following examples demonstrate these advantages in practice, showing how MES and category theory provide a more powerful framework for modeling complex dynamical systems.","category":"page"},{"location":"state_space_models.html#Memory","page":"State Space Models","title":"Memory","text":"","category":"section"},{"location":"state_space_models.html","page":"State Space Models","title":"State Space Models","text":"The TimeSeriesMemory type provides a structured way to store and manage time series data with explicit temporal relationships between states. It maintains three key components:","category":"page"},{"location":"state_space_models.html","page":"State Space Models","title":"State Space Models","text":"times: Vector of time points\nstates: Vector of state values\nlinks: Vector of morphisms connecting consecutive states","category":"page"},{"location":"state_space_models.html#Core-Functions","page":"State Space Models","title":"Core Functions","text":"","category":"section"},{"location":"state_space_models.html","page":"State Space Models","title":"State Space Models","text":"# Create a new time series memory\nTimeSeriesMemory(initial_time::Object{Float64}, initial_state::Object{T})\n\n# Extend memory with new time point and state\nextend!(memory::TimeSeriesMemory{T}, new_time::Object{Float64}, new_state::Object{T}, link::Morphism)\n\n# Access memory components\nget_data(memory::TimeSeriesMemory)::Vector{T}\nget_times(memory::TimeSeriesMemory)::Vector{Float64}\nget_links(memory::TimeSeriesMemory)::Vector{Morphism}","category":"page"},{"location":"state_space_models.html#Example","page":"State Space Models","title":"Example","text":"","category":"section"},{"location":"state_space_models.html","page":"State Space Models","title":"State Space Models","text":"# Create initial memory\nt₁ = Object(:t1, 1.0)\ns₁ = Object(:s1, [1.0])\nmemory = TimeSeriesMemory(t₁, s₁)\n\n# Verify initial state\n@assert length(memory.times) == 1\n@assert length(memory.states) == 1\n@assert length(memory.links) == 0\n\n# Extend memory with new state\nt₂ = Object(:t2, 2.0)\ns₂ = Object(:s2, [2.0])\nlink = Morphism(s₁, s₂, x -> 2.0 * x, :link)\nextend!(memory, t₂, s₂, link)\n\n# Verify extended state\n@assert length(memory.times) == 2\n@assert length(memory.states) == 2\n@assert length(memory.links) == 1\n\n# Access memory components\ndata = get_data(memory)\ntimes = get_times(memory)\nlinks = get_links(memory)\n\n# Verify data types and values\n@assert length(data) == 2\n@assert length(times) == 2\n@assert length(links) == 1\n@assert all(x -> x isa Vector{Float64}, data)\n@assert all(x -> x isa Float64, times)\n@assert all(x -> x isa Morphism, links)\n@assert data[1] == [1.0]\n@assert data[2] == [2.0]\n@assert times[1] == 1.0\n@assert times[2] == 2.0","category":"page"},{"location":"state_space_models.html#AR(1)-Model","page":"State Space Models","title":"AR(1) Model","text":"","category":"section"},{"location":"state_space_models.html","page":"State Space Models","title":"State Space Models","text":"The first-order autoregressive model represents a simple state space model where the next state depends linearly on the current state:","category":"page"},{"location":"state_space_models.html","page":"State Space Models","title":"State Space Models","text":"x_t+1 = alpha x_t","category":"page"},{"location":"state_space_models.html","page":"State Space Models","title":"State Space Models","text":"where (\\alpha) is the autoregression coefficient.","category":"page"},{"location":"state_space_models.html#Implementation","page":"State Space Models","title":"Implementation","text":"","category":"section"},{"location":"state_space_models.html","page":"State Space Models","title":"State Space Models","text":"The AR(1) model is implemented using the following functions:","category":"page"},{"location":"state_space_models.html","page":"State Space Models","title":"State Space Models","text":"function create_ar_model(initial_state::Vector{Float64})\n    t₁ = Object(:t1, 1.0)\n    s₁ = Object(:s1, initial_state)\n\n    time_step = Morphism(t₁, Object(:t2, 2.0), t -> t + 1.0, :time_step)\n    evolution = Morphism(s₁, Object(:s2, [0.0]), x -> [0.7 * x[1]], :evolution)\n\n    return t₁, s₁, time_step, evolution\nend","category":"page"},{"location":"state_space_models.html","page":"State Space Models","title":"State Space Models","text":"This implementation uses category theory concepts:","category":"page"},{"location":"state_space_models.html","page":"State Space Models","title":"State Space Models","text":"Objects represent time points and states\nMorphisms represent the evolution of time and states\nThe time step morphism maps each time point to the next one\nThe evolution morphism implements the AR(1) equation x_t+1 = alpha x_t with alpha = 07","category":"page"},{"location":"state_space_models.html#Example-2","page":"State Space Models","title":"Example","text":"","category":"section"},{"location":"state_space_models.html","page":"State Space Models","title":"State Space Models","text":"# Create and simulate AR(1) model\nt₁, s₁, time_step, evolution = create_ar_model([0.5])\nmemory = simulate_dynamics(t₁, s₁, time_step, evolution, 5)\n\n# Verify the model behavior\n@test s₁.data == [0.5]\n@test time_step.map(1.0) == 2.0\n@test evolution.map([0.5]) == [0.35]","category":"page"},{"location":"state_space_models.html#VAR(1)-Model","page":"State Space Models","title":"VAR(1) Model","text":"","category":"section"},{"location":"state_space_models.html","page":"State Space Models","title":"State Space Models","text":"The first-order vector autoregressive model extends the AR(1) model to multiple dimensions:","category":"page"},{"location":"state_space_models.html","page":"State Space Models","title":"State Space Models","text":"mathbfx_t+1 = Amathbfx_t","category":"page"},{"location":"state_space_models.html","page":"State Space Models","title":"State Space Models","text":"where (A) is the coefficient matrix and (\\mathbf{x}_t) is a vector of states.","category":"page"},{"location":"state_space_models.html#Implementation-2","page":"State Space Models","title":"Implementation","text":"","category":"section"},{"location":"state_space_models.html","page":"State Space Models","title":"State Space Models","text":"The VAR(1) model is implemented using:","category":"page"},{"location":"state_space_models.html","page":"State Space Models","title":"State Space Models","text":"function create_var_model(initial_state::Vector{Float64}, A::Matrix{Float64})\n    t₁ = Object(:t1, 1.0)\n    s₁ = Object(:s1, initial_state)\n\n    time_step = Morphism(t₁, Object(:t2, 2.0), t -> t + 1.0, :time_step)\n    evolution = Morphism(s₁, Object(:s2, similar(initial_state)), x -> A * x, :evolution)\n\n    return t₁, s₁, time_step, evolution\nend","category":"page"},{"location":"state_space_models.html","page":"State Space Models","title":"State Space Models","text":"This implementation extends the AR(1) model to multiple dimensions:","category":"page"},{"location":"state_space_models.html","page":"State Space Models","title":"State Space Models","text":"Uses the same categorical structure with Objects and Morphisms\nThe evolution morphism implements the VAR(1) equation mathbfx_t+1 = Amathbfx_t\nMatrix multiplication is used to compute the next state vector","category":"page"},{"location":"state_space_models.html#Example-3","page":"State Space Models","title":"Example","text":"","category":"section"},{"location":"state_space_models.html","page":"State Space Models","title":"State Space Models","text":"# Create and simulate VAR(1) model\nA = [0.5 0.2; 0.1 0.6]\nt₁, s₁, time_step, evolution = create_var_model([1.0, 2.0], A)\nmemory = simulate_dynamics(t₁, s₁, time_step, evolution, 100)\n\n# Verify the model behavior\n@test s₁.data == [1.0, 2.0]\n@test evolution.map([1.0, 2.0]) .== A * [1.0, 2.0]","category":"page"},{"location":"state_space_models.html#Nonlinear-VAR-Model","page":"State Space Models","title":"Nonlinear VAR Model","text":"","category":"section"},{"location":"state_space_models.html","page":"State Space Models","title":"State Space Models","text":"The nonlinear VAR model introduces nonlinear transformations to the state evolution:","category":"page"},{"location":"state_space_models.html","page":"State Space Models","title":"State Space Models","text":"mathbfx_t+1 = f(Amathbfx_t)","category":"page"},{"location":"state_space_models.html","page":"State Space Models","title":"State Space Models","text":"where (f) is a nonlinear function applied element-wise.","category":"page"},{"location":"state_space_models.html#Implementation-3","page":"State Space Models","title":"Implementation","text":"","category":"section"},{"location":"state_space_models.html","page":"State Space Models","title":"State Space Models","text":"The nonlinear VAR model is implemented using:","category":"page"},{"location":"state_space_models.html","page":"State Space Models","title":"State Space Models","text":"function create_nonlinear_var_model(initial_state::Vector{Float64}, A::Matrix{Float64})\n    t₁ = Object(:t1, 1.0)\n    s₁ = Object(:s1, initial_state)\n\n    time_step = Morphism(t₁, Object(:t2, 2.0), t -> t + 1.0, :time_step)\n    evolution = Morphism(s₁, Object(:s2, similar(initial_state)), x -> A * x + 0.1 * sin.(x), :evolution)\n\n    return t₁, s₁, time_step, evolution\nend","category":"page"},{"location":"state_space_models.html","page":"State Space Models","title":"State Space Models","text":"This implementation adds nonlinearity to the VAR model:","category":"page"},{"location":"state_space_models.html","page":"State Space Models","title":"State Space Models","text":"Maintains the same categorical structure\nThe evolution morphism combines linear transformation with nonlinear sine function\nThe nonlinear term 01sin(mathbfx) is applied element-wise to the state vector","category":"page"},{"location":"state_space_models.html#Example-4","page":"State Space Models","title":"Example","text":"","category":"section"},{"location":"state_space_models.html","page":"State Space Models","title":"State Space Models","text":"# Create and simulate nonlinear VAR model\nt₁, s₁, time_step, evolution = create_nonlinear_var_model([1.0, 0.5], A)\nmemory = simulate_dynamics(t₁, s₁, time_step, evolution, 100)\n\n# Verify the model behavior\n@test s₁.data == [1.0, 0.5]\n@test evolution.map isa Function\nresult = evolution.map([1.0, 0.5])\n@test length(result) == 2\n@test all(isfinite, result)","category":"page"},{"location":"state_space_models.html#Stochastic-Nonlinear-VAR-Model","page":"State Space Models","title":"Stochastic Nonlinear VAR Model","text":"","category":"section"},{"location":"state_space_models.html","page":"State Space Models","title":"State Space Models","text":"The stochastic nonlinear VAR model adds random components to the state evolution:","category":"page"},{"location":"state_space_models.html","page":"State Space Models","title":"State Space Models","text":"mathbfx_t+1 = f(Amathbfx_t) + boldsymbolepsilon_t","category":"page"},{"location":"state_space_models.html","page":"State Space Models","title":"State Space Models","text":"where (\\boldsymbol{\\epsilon}_t) is a random noise vector.","category":"page"},{"location":"state_space_models.html#Implementation-4","page":"State Space Models","title":"Implementation","text":"","category":"section"},{"location":"state_space_models.html","page":"State Space Models","title":"State Space Models","text":"The stochastic nonlinear VAR model is implemented using:","category":"page"},{"location":"state_space_models.html","page":"State Space Models","title":"State Space Models","text":"function create_stochastic_nonlinear_var_model(initial_state::Vector{Float64}, A::Matrix{Float64})\n    t₁ = Object(:t1, 1.0)\n    s₁ = Object(:s1, initial_state)\n\n    time_step = Morphism(t₁, Object(:t2, 2.0), t -> t + 1.0, :time_step)\n    evolution = Morphism(s₁, Object(:s2, similar(initial_state)), \n                        x -> A * x + 0.1 * sin.(x) + 0.1 * randn(length(x)), :evolution)\n\n    return t₁, s₁, time_step, evolution\nend","category":"page"},{"location":"state_space_models.html","page":"State Space Models","title":"State Space Models","text":"This implementation adds stochasticity to the nonlinear VAR model:","category":"page"},{"location":"state_space_models.html","page":"State Space Models","title":"State Space Models","text":"Uses the same categorical structure\nThe evolution morphism combines:\nLinear transformation Amathbfx\nNonlinear term 01sin(mathbfx)\nRandom noise 01boldsymbolepsilon where boldsymbolepsilon sim mathcalN(01)\nEach call to the evolution morphism produces a different result due to the random component","category":"page"},{"location":"state_space_models.html#Example-5","page":"State Space Models","title":"Example","text":"","category":"section"},{"location":"state_space_models.html","page":"State Space Models","title":"State Space Models","text":"# Create and simulate stochastic nonlinear VAR model\nt₁, s₁, time_step, evolution = create_stochastic_nonlinear_var_model([1.0, 0.5], A)\nmemory = simulate_dynamics(t₁, s₁, time_step, evolution, 100)\n\n# Verify the model behavior\n@test s₁.data == [1.0, 0.5]\n@test evolution.map isa Function\nresults = [evolution.map([1.0, 0.5]) for _ in 1:10]\n@test all(x -> length(x) == 2, results)\n@test all(x -> all(isfinite, x), results)\n@test length(unique(results)) > 1  # Ensure stochastic behavior","category":"page"},{"location":"state_space_models.html#Visualization","page":"State Space Models","title":"Visualization","text":"","category":"section"},{"location":"state_space_models.html","page":"State Space Models","title":"State Space Models","text":"The state space models can be visualized using the following functions:","category":"page"},{"location":"state_space_models.html","page":"State Space Models","title":"State Space Models","text":"# Create time series plots for each model\np1 = plot_timeseries(ar1_memory, \"Deterministic Linear AR(1)\")\np2 = plot_timeseries(var1_memory, \"Deterministic Linear VAR(1)\")\np3 = plot_timeseries(nonlinear_memory, \"Deterministic Nonlinear VAR\")\np4 = plot_timeseries(stochastic_memory, \"Stochastic Nonlinear VAR\")\n\n# Create comparison plot\ncomparison_plot = plot(p1, p2, p3, p4, layout=(2, 2), size=(1000, 1000))\nsavefig(comparison_plot, \"dynamics_comparison.png\")","category":"page"},{"location":"state_space_models.html","page":"State Space Models","title":"State Space Models","text":"This will generate a 2x2 grid of plots comparing the behavior of all four models, saved as \"dynamics_comparison.png\".","category":"page"},{"location":"state_space_models.html","page":"State Space Models","title":"State Space Models","text":"(Image: Comparison of different state space models)","category":"page"},{"location":"mes07.html#MES07:-Memory-Evolutive-Systems","page":"MES07: Memory Evolutive Systems","title":"MES07: Memory Evolutive Systems","text":"","category":"section"},{"location":"mes07.html#Overview","page":"MES07: Memory Evolutive Systems","title":"Overview","text":"","category":"section"},{"location":"mes07.html","page":"MES07: Memory Evolutive Systems","title":"MES07: Memory Evolutive Systems","text":"This foundational paper introduces Memory Evolutive Systems (MES) as mathematical models for autonomous evolutionary systems, particularly focusing on biological and social systems, including nervous systems of higher animals. The work is rooted in category theory and represents two decades of research development.","category":"page"},{"location":"mes07.html#Key-Concepts","page":"MES07: Memory Evolutive Systems","title":"Key Concepts","text":"","category":"section"},{"location":"mes07.html#Complexity-Characterization","page":"MES07: Memory Evolutive Systems","title":"Complexity Characterization","text":"","category":"section"},{"location":"mes07.html","page":"MES07: Memory Evolutive Systems","title":"MES07: Memory Evolutive Systems","text":"The paper addresses three fundamental problems:","category":"page"},{"location":"mes07.html","page":"MES07: Memory Evolutive Systems","title":"MES07: Memory Evolutive Systems","text":"The Binding Problem: How simple objects combine to form a \"whole greater than the sum of its parts\"\nThe Emergence Problem: How properties of complex objects relate to their elementary components\nThe Hierarchy Problem: Explaining the formation of increasingly complex objects, from elementary particles to societies","category":"page"},{"location":"mes07.html#Self-Regulation","page":"MES07: Memory Evolutive Systems","title":"Self-Regulation","text":"","category":"section"},{"location":"mes07.html","page":"MES07: Memory Evolutive Systems","title":"MES07: Memory Evolutive Systems","text":"The paper introduces key characteristics that allow for autonomy through self-regulation:","category":"page"},{"location":"mes07.html","page":"MES07: Memory Evolutive Systems","title":"MES07: Memory Evolutive Systems","text":"Internal regulation systems\nCapacity to recognize environmental characteristics\nDevelopment of appropriate responses\nIntroduction of co-regulators (CR) for different hierarchy levels\nFlexible memory systems for adaptation","category":"page"},{"location":"mes07.html#Cognitive-Systems","page":"MES07: Memory Evolutive Systems","title":"Cognitive Systems","text":"","category":"section"},{"location":"mes07.html","page":"MES07: Memory Evolutive Systems","title":"MES07: Memory Evolutive Systems","text":"The paper explores applications to:","category":"page"},{"location":"mes07.html","page":"MES07: Memory Evolutive Systems","title":"MES07: Memory Evolutive Systems","text":"Nervous system modeling\nCognition processes\nConsciousness modeling\nDevelopment of personal memory (archetypal core)","category":"page"},{"location":"mes07.html#Mathematical-Framework","page":"MES07: Memory Evolutive Systems","title":"Mathematical Framework","text":"","category":"section"},{"location":"mes07.html","page":"MES07: Memory Evolutive Systems","title":"MES07: Memory Evolutive Systems","text":"The model uses:","category":"page"},{"location":"mes07.html","page":"MES07: Memory Evolutive Systems","title":"MES07: Memory Evolutive Systems","text":"Category theory as the foundational mathematical structure\nComplex systems theory\nHierarchical evolutive systems based on colimit concepts\nNetwork theory for co-regulator interactions","category":"page"},{"location":"mes07.html#Applications","page":"MES07: Memory Evolutive Systems","title":"Applications","text":"","category":"section"},{"location":"mes07.html","page":"MES07: Memory Evolutive Systems","title":"MES07: Memory Evolutive Systems","text":"The framework has applications in:","category":"page"},{"location":"mes07.html","page":"MES07: Memory Evolutive Systems","title":"MES07: Memory Evolutive Systems","text":"Biology\nMedicine\nSociology\nEcology\nEconomics\nComplex systems analysis","category":"page"},{"location":"mes07.html#Historical-Context","page":"MES07: Memory Evolutive Systems","title":"Historical Context","text":"","category":"section"},{"location":"mes07.html","page":"MES07: Memory Evolutive Systems","title":"MES07: Memory Evolutive Systems","text":"The work emerged from a collaboration between:","category":"page"},{"location":"mes07.html","page":"MES07: Memory Evolutive Systems","title":"MES07: Memory Evolutive Systems","text":"Jean-Paul Vanbremeersch (physician specializing in gerontology)\nAndrée C. Ehresmann (mathematician)","category":"page"},{"location":"mes07.html","page":"MES07: Memory Evolutive Systems","title":"MES07: Memory Evolutive Systems","text":"Their collaboration began in 1980, leading to the development of MES theory.","category":"page"},{"location":"geometric_system.html#Geometric-System","page":"Geometric System","title":"Geometric System","text":"","category":"section"},{"location":"geometric_system.html","page":"Geometric System","title":"Geometric System","text":"Category theory provides a powerful framework for handling geometric systems by offering a structured way to represent and manipulate geometric objects and their relationships. This approach has several key benefits:","category":"page"},{"location":"geometric_system.html","page":"Geometric System","title":"Geometric System","text":"Structured Representation: Geometric objects (points, lines, shapes) can be represented as objects in a category, while geometric transformations (translations, rotations, scaling) are represented as morphisms between these objects.\nComposition of Transformations: Category theory's composition rules naturally capture how geometric transformations can be combined. For example, a rotation followed by a translation can be represented as the composition of two morphisms.\nInvariant Properties: The categorical framework helps maintain geometric invariants. For instance, when we define a morphism that transforms a point into a line, we can ensure it preserves important geometric properties.\nPattern Recognition: Categories allow us to identify and work with geometric patterns as subcategories, making it easier to recognize and manipulate recurring geometric structures.\nHierarchical Organization: Complex geometric systems can be organized hierarchically using categories and subcategories, reflecting the natural structure of geometric relationships.","category":"page"},{"location":"geometric_system.html","page":"Geometric System","title":"Geometric System","text":"The following example demonstrates how we can implement these concepts using our category theory framework:","category":"page"},{"location":"geometric_system.html","page":"Geometric System","title":"Geometric System","text":"using Moma\n\n# Define custom data types for geometric objects\n# Point represents a 2D point with x and y coordinates\nstruct Point\n    x::Float64\n    y::Float64\nend\n\n# Line represents a line segment with start and end points\nstruct Line\n    start::Point\n    ends::Point\nend\n\n# Create objects in our category using the custom data types\n# Each object has a unique identifier (symbol) and associated data\np1 = Object(:P1, Point(0.0, 0.0))  # Point at origin\np2 = Object(:P2, Point(1.0, 1.0))  # Point at (1,1)\nl1 = Object(:L1, Line(Point(0.0, 0.0), Point(1.0, 1.0)))  # Line from origin to (1,1)\n\n# Verify that objects are created correctly by checking their data\n# This ensures our objects maintain their geometric properties\n@assert p1.data.x == 0.0\n@assert p1.data.y == 0.0\n@assert p2.data.x == 1.0\n@assert p2.data.y == 1.0\n@assert l1.data.start.x == 0.0\n@assert l1.data.start.y == 0.0\n@assert l1.data.ends.x == 1.0\n@assert l1.data.ends.y == 1.0\n@assert p1.id == :P1\n@assert p2.id == :P2\n@assert l1.id == :L1\n\n# Create a morphism that transforms a point into a line\n# This morphism takes a point and creates a line from that point to a point 1 unit right and up\nf = Morphism(p1, l1, p -> Line(p, Point(p.x + 1.0, p.y + 1.0)), :f)\n\n# Verify that the morphism correctly transforms the point into a line\n# This ensures our morphisms preserve geometric relationships\nresult = f.map(p1.data)\n@assert result.start.x == 0.0\n@assert result.start.y == 0.0\n@assert result.ends.x == 1.0\n@assert result.ends.y == 1.0\n@assert f.id == :f\n@assert f.source == p1\n@assert f.target == l1\n\n# Create a category that contains our geometric objects and morphisms\n# This category represents our geometric system\ngeom_cat = Category([p1, p2, l1], [f], :Geometry)\n@assert length(geom_cat.objects) == 3\n@assert length(geom_cat.morphisms) == 1\n@assert geom_cat.id == :Geometry\n@assert p1 in geom_cat.objects\n@assert p2 in geom_cat.objects\n@assert l1 in geom_cat.objects\n@assert f in geom_cat.morphisms\n\n# Create a pattern within our geometric category\n# A pattern is a subcategory that represents a specific geometric configuration\n# Here we create a pattern with a point and a line, connected by our morphism\ngeom_pattern = create_pattern(geom_cat, [p1, l1], [f])\n@assert length(geom_pattern.objects) == 2\n@assert length(geom_pattern.morphisms) == 1\n@assert geom_pattern.category == geom_cat\n@assert p1 in geom_pattern.objects\n@assert l1 in geom_pattern.objects\n@assert f in geom_pattern.morphisms","category":"page"},{"location":"geometric_system.html","page":"Geometric System","title":"Geometric System","text":"","category":"page"},{"location":"api.html#API-Reference","page":"API","title":"API Reference","text":"","category":"section"},{"location":"api.html#Overview","page":"API","title":"Overview","text":"","category":"section"},{"location":"api.html","page":"API","title":"API","text":"The Categories module provides implementations of fundamental category theory concepts used in Memory Evolutive Systems (MES). This includes:","category":"page"},{"location":"api.html","page":"API","title":"API","text":"Basic categorical constructions (objects, morphisms, categories)\nFunctorial mappings between categories\nNatural transformations between functors\nPattern (diagram) creation and manipulation\nColimit computation and verification","category":"page"},{"location":"api.html#Modules","page":"API","title":"Modules","text":"","category":"section"},{"location":"api.html","page":"API","title":"API","text":"Modules = [Moma.Categories, Moma.StateSpace]\nOrder = [:module]","category":"page"},{"location":"api.html#Moma.Categories","page":"API","title":"Moma.Categories","text":"module Categories\n\nThis module provides basic categorical constructions used in Memory Evolutive Systems (MES). It includes implementations of objects, morphisms, categories, functors, natural transformations, and patterns, along with functions for working with these constructions.\n\nMathematical Background\n\nThe module implements core concepts from category theory:\n\nObjects and morphisms form categories with composition and identity laws\nFunctors preserve structure between categories\nNatural transformations connect functors\nColimits represent universal constructions\n\nExports\n\nObject: Represents an object in a category\nMorphism: Represents a morphism between objects\nCategory: Represents a category with objects and morphisms\nFunctor: Represents a functor between categories\nNaturalTransformation: Represents a natural transformation between functors\nPattern: Represents a pattern (diagram) in a category\nidentity: Creates an identity morphism for an object\ncompose: Composes two morphisms\ncreate_pattern: Creates a pattern from objects and morphisms\ncheck_binding: Checks if an object forms a colimit for a pattern\nfind_colimit: Finds or constructs colimits for patterns\nis_morphism_in_category: Checks if a morphism belongs to a category\n\n\n\n\n\n","category":"module"},{"location":"api.html#Types","page":"API","title":"Types","text":"","category":"section"},{"location":"api.html#Basic-Types","page":"API","title":"Basic Types","text":"","category":"section"},{"location":"api.html","page":"API","title":"API","text":"Moma.Categories.Object\nMoma.Categories.Morphism\nMoma.Categories.Category\nMoma.StateSpace.TimeSeriesMemory","category":"page"},{"location":"api.html#Moma.Categories.Object","page":"API","title":"Moma.Categories.Object","text":"Object{T}\n\nRepresents an object in a category.\n\nType Parameters\n\nT: The type of data associated with the object\n\nFields\n\nid::Symbol: Unique identifier for the object\ndata::T: Data associated with the object\n\nExamples\n\n# Create an object with string data\nobj = Object(:A, \"data\")\n\n# Create an object with numeric data\nnum_obj = Object(:B, 42)\n\n# Create an object with custom type\nstruct Point\n    x::Float64\n    y::Float64\nend\npoint_obj = Object(:P, Point(0.0, 1.0))\n\n\n\n\n\n","category":"type"},{"location":"api.html#Moma.Categories.Morphism","page":"API","title":"Moma.Categories.Morphism","text":"Morphism{S,T}\n\nRepresents a morphism between objects in a category.\n\nType Parameters\n\nS: The type of data in the source object\nT: The type of data in the target object\n\nFields\n\nsource::Object{S}: Source object\ntarget::Object{T}: Target object\nmap::Function: Function mapping source to target\nid::Symbol: Unique identifier for the morphism\n\nExamples\n\n# Create objects\nA = Object(:A, \"hello\")\nB = Object(:B, \"HELLO\")\n\n# Create a morphism that uppercases strings\nf = Morphism(A, B, uppercase, :f)\n@assert f.map(A.data) == B.data\n\n# Create a morphism between numeric objects\nX = Object(:X, 1)\nY = Object(:Y, 2)\ng = Morphism(X, Y, x -> x + 1, :g)\n\n\n\n\n\n","category":"type"},{"location":"api.html#Moma.Categories.Category","page":"API","title":"Moma.Categories.Category","text":"Category\n\nRepresents a category with objects and morphisms.\n\nFields\n\nobjects::Vector{<:Object}: Objects in the category\nmorphisms::Vector{<:Morphism}: Morphisms in the category\nid::Symbol: Unique identifier for the category\n\n\n\n\n\n","category":"type"},{"location":"api.html#Moma.StateSpace.TimeSeriesMemory","page":"API","title":"Moma.StateSpace.TimeSeriesMemory","text":"TimeSeriesMemory{T}\n\nA type for storing time series data in a Memory Evolutive Systems (MES) style.\n\nFields\n\ntimes::Vector{Object{Float64}}: Time objects representing the temporal dimension\nstates::Vector{Object{T}}: State objects representing the system's evolution\nlinks::Vector{Morphism{T,T}}: Links between consecutive states (morphisms)\n\nConstructors\n\nTimeSeriesMemory{T}(initial_time::Object{Float64}, initial_state::Object{T}) where {T}\nTimeSeriesMemory(initial_time::Object{Float64}, initial_state::Object{T}) where {T}\n\n\n\n\n\n","category":"type"},{"location":"api.html#Advanced-Types","page":"API","title":"Advanced Types","text":"","category":"section"},{"location":"api.html","page":"API","title":"API","text":"Moma.Categories.Functor\nMoma.Categories.NaturalTransformation\nMoma.Categories.Pattern","category":"page"},{"location":"api.html#Moma.Categories.Functor","page":"API","title":"Moma.Categories.Functor","text":"Functor\n\nRepresents a functor between categories.\n\nFields\n\nsource::Category: Source category\ntarget::Category: Target category\nobject_map::Dict{<:Object,<:Object}: Mapping of objects\nmorphism_map::Dict{<:Morphism,<:Morphism}: Mapping of morphisms\nid::Symbol: Unique identifier for the functor\n\n\n\n\n\n","category":"type"},{"location":"api.html#Moma.Categories.NaturalTransformation","page":"API","title":"Moma.Categories.NaturalTransformation","text":"NaturalTransformation\n\nRepresents a natural transformation between functors.\n\nFields\n\nsource::Functor: Source functor\ntarget::Functor: Target functor\ncomponents::Dict{<:Object,<:Morphism}: Component morphisms\nid::Symbol: Unique identifier for the natural transformation\n\n\n\n\n\n","category":"type"},{"location":"api.html#Moma.Categories.Pattern","page":"API","title":"Moma.Categories.Pattern","text":"Pattern\n\nRepresents a pattern (diagram) in a category.\n\nFields\n\ncategory::Category: The category containing the pattern\nobjects::Vector{<:Object}: Objects in the pattern\nmorphisms::Vector{<:Morphism}: Morphisms in the pattern\nid::Symbol: Unique identifier for the pattern\n\n\n\n\n\n","category":"type"},{"location":"api.html#Functions","page":"API","title":"Functions","text":"","category":"section"},{"location":"api.html#Basic-Operations","page":"API","title":"Basic Operations","text":"","category":"section"},{"location":"api.html","page":"API","title":"API","text":"Moma.Categories.identity\nMoma.Categories.compose\nMoma.Categories.is_morphism_in_category","category":"page"},{"location":"api.html#Moma.Categories.identity","page":"API","title":"Moma.Categories.identity","text":"identity(obj::Object)\n\nCreate an identity morphism for an object.\n\nArguments\n\nobj::Object: The object to create an identity morphism for\n\nReturns\n\nMorphism: A morphism from the object to itself with the identity function\n\nExamples\n\nA = Object(:A, \"data\")\nid_A = identity(A)\n@assert id_A.map(A.data) == A.data\n\n\n\n\n\n","category":"function"},{"location":"api.html#Moma.Categories.compose","page":"API","title":"Moma.Categories.compose","text":"compose(f::Morphism, g::Morphism)\n\nCompose two morphisms if they are composable (target of f equals source of g).\n\nArguments\n\nf::Morphism{S,T}: First morphism\ng::Morphism{T,U}: Second morphism\n\nReturns\n\nMorphism{S,U}: The composition g ∘ f\n\nThrows\n\nErrorException: If the morphisms are not composable (f.target ≠ g.source)\n\nExamples\n\n# Create objects and morphisms\nA = Object(:A, \"hello\")\nB = Object(:B, \"HELLO\")\nC = Object(:C, \"HELLO!\")\nf = Morphism(A, B, uppercase, :f)\ng = Morphism(B, C, s -> s * \"!\", :g)\n\n# Compose morphisms\nh = compose(f, g)\n@assert h.map(\"hello\") == \"HELLO!\"\n\n# This will throw an error\nk = Morphism(C, A, lowercase, :k)\ncompose(f, k)  # Error: Morphisms are not composable\n\n\n\n\n\n","category":"function"},{"location":"api.html#Moma.Categories.is_morphism_in_category","page":"API","title":"Moma.Categories.is_morphism_in_category","text":"is_morphism_in_category(morphism::Morphism, category::Category)\n\nCheck if a morphism belongs to a category.\n\nArguments\n\nmorphism::Morphism: The morphism to check\ncategory::Category: The category to check against\n\nReturns\n\nBool: true if the morphism belongs to the category, false otherwise\n\nExamples\n\n# Create objects and a morphism\nA = Object(:A, 1)\nB = Object(:B, 2)\nf = Morphism(A, B, x -> x + 1, :f)\n\n# Create a category and check membership\nC = Category([A, B], [f], :C)\n@assert is_morphism_in_category(f, C)\n\n# Check a morphism not in the category\ng = Morphism(B, A, x -> x - 1, :g)\n@assert !is_morphism_in_category(g, C)\n\n\n\n\n\n","category":"function"},{"location":"api.html#Pattern-and-Colimit-Operations","page":"API","title":"Pattern and Colimit Operations","text":"","category":"section"},{"location":"api.html","page":"API","title":"API","text":"Moma.Categories.create_pattern\nMoma.Categories.check_binding\nMoma.Categories.find_colimit","category":"page"},{"location":"api.html#Moma.Categories.create_pattern","page":"API","title":"Moma.Categories.create_pattern","text":"create_pattern(category::Category, objects::Vector{<:Object}, morphisms::Vector{<:Morphism})\n\nCreate a pattern (diagram) from a subset of objects and morphisms in a category.\n\nArguments\n\ncategory::Category: The category containing the objects and morphisms\nobjects::Vector{<:Object}: Objects to include in the pattern\nmorphisms::Vector{<:Morphism}: Morphisms to include in the pattern\n\nReturns\n\nPattern: A new pattern containing the specified objects and morphisms\n\nThrows\n\nErrorException: If any object or morphism does not belong to the category\n\nExamples\n\n# Create objects and morphisms\nA = Object(:A, 1)\nB = Object(:B, 2)\nf = Morphism(A, B, x -> x + 1, :f)\n\n# Create category and pattern\nC = Category([A, B], [f], :C)\nP = create_pattern(C, [A, B], [f])\n\n# This will throw an error\nX = Object(:X, 0)\ncreate_pattern(C, [A, X], [f])  # Error: Objects must belong to the category\n\n\n\n\n\n","category":"function"},{"location":"api.html#Moma.Categories.check_binding","page":"API","title":"Moma.Categories.check_binding","text":"check_binding(object::Object, bindings::Dict{<:Object,<:Morphism}, pattern::Pattern)\n\nCheck if an object with specified bindings forms a colimit for a pattern.\n\nArguments\n\nobject::Object: The candidate colimit object\nbindings::Dict{<:Object,<:Morphism}: Morphisms from pattern objects to the candidate\npattern::Pattern: The pattern to check\n\nReturns\n\nBool: true if the object with bindings forms a colimit, false otherwise\n\n\n\n\n\n","category":"function"},{"location":"api.html#Moma.Categories.find_colimit","page":"API","title":"Moma.Categories.find_colimit","text":"find_colimit(pattern::Pattern)\n\nFind or construct a colimit for a pattern.\n\nArguments\n\npattern::Pattern: The pattern to find a colimit for\n\nReturns\n\nTuple{Object,Dict{<:Object,<:Morphism}}: A tuple containing the colimit object and bindings\n\n\n\n\n\n","category":"function"},{"location":"api.html#State-Space-Operations","page":"API","title":"State Space Operations","text":"","category":"section"},{"location":"api.html","page":"API","title":"API","text":"Moma.StateSpace.create_ar_model\nMoma.StateSpace.create_var_model\nMoma.StateSpace.create_nonlinear_var_model\nMoma.StateSpace.create_stochastic_nonlinear_var_model\nMoma.StateSpace.simulate_dynamics\nMoma.StateSpace.plot_timeseries\nMoma.StateSpace.get_data\nMoma.StateSpace.get_times\nMoma.StateSpace.extend!\nMoma.StateSpace.collect_timeseries\nMoma.StateSpace.get_links","category":"page"},{"location":"api.html#Moma.StateSpace.create_ar_model","page":"API","title":"Moma.StateSpace.create_ar_model","text":"create_ar_model(initial_state::Vector{Float64})\n\nCreate an AR(1) model.\n\nArguments\n\ninitial_state::Vector{Float64}: Initial state vector\n\nReturns\n\nTuple of (initialtime, initialstate, time_step, evolution)\n\n\n\n\n\n","category":"function"},{"location":"api.html#Moma.StateSpace.create_var_model","page":"API","title":"Moma.StateSpace.create_var_model","text":"create_var_model(initial_state::Vector{Float64}, A::Matrix{Float64})\n\nCreate a VAR(1) model.\n\nArguments\n\ninitial_state::Vector{Float64}: Initial state vector\nA::Matrix{Float64}: Transition matrix\n\nReturns\n\nTuple of (initialtime, initialstate, time_step, evolution)\n\n\n\n\n\n","category":"function"},{"location":"api.html#Moma.StateSpace.create_nonlinear_var_model","page":"API","title":"Moma.StateSpace.create_nonlinear_var_model","text":"create_nonlinear_var_model(initial_state::Vector{Float64}, A::Matrix{Float64})\n\nCreate a nonlinear VAR model.\n\nArguments\n\ninitial_state::Vector{Float64}: Initial state vector\nA::Matrix{Float64}: Transition matrix\n\nReturns\n\nTuple of (initialtime, initialstate, time_step, evolution)\n\n\n\n\n\n","category":"function"},{"location":"api.html#Moma.StateSpace.create_stochastic_nonlinear_var_model","page":"API","title":"Moma.StateSpace.create_stochastic_nonlinear_var_model","text":"create_stochastic_nonlinear_var_model(initial_state::Vector{Float64}, A::Matrix{Float64})\n\nCreate a stochastic nonlinear VAR model.\n\nArguments\n\ninitial_state::Vector{Float64}: Initial state vector\nA::Matrix{Float64}: Transition matrix\n\nReturns\n\nTuple of (initialtime, initialstate, time_step, evolution)\n\n\n\n\n\n","category":"function"},{"location":"api.html#Moma.StateSpace.simulate_dynamics","page":"API","title":"Moma.StateSpace.simulate_dynamics","text":"simulate_dynamics(t₁::Object{Float64}, s₁::Object{T}, time_step::Morphism, evolution::Morphism, n_steps::Int)\n\nSimulate the dynamics of a system.\n\nArguments\n\nt₁::Object{Float64}: Initial time\ns₁::Object{T}: Initial state\ntime_step::Morphism: Time step morphism\nevolution::Morphism: Evolution morphism\nn_steps::Int: Number of steps to simulate\n\nReturns\n\nTimeSeriesMemory{T} containing the simulation results\n\n\n\n\n\n","category":"function"},{"location":"api.html#Moma.StateSpace.plot_timeseries","page":"API","title":"Moma.StateSpace.plot_timeseries","text":"plot_timeseries(memory::TimeSeriesMemory{T}, title::String=\"Time Series\")\n\nCreate a plot of the time series data.\n\nArguments\n\nmemory::TimeSeriesMemory{T}: The memory to plot\ntitle::String: Title for the plot\n\nReturns\n\nPlots.Plot object\n\n\n\n\n\n","category":"function"},{"location":"api.html#Moma.StateSpace.get_data","page":"API","title":"Moma.StateSpace.get_data","text":"get_data(memory::TimeSeriesMemory{T})\n\nExtract the state data from memory as a vector of values.\n\nArguments\n\nmemory::TimeSeriesMemory{T}: The memory to extract data from\n\nReturns\n\nVector of state values\n\n\n\n\n\n","category":"function"},{"location":"api.html#Moma.StateSpace.get_times","page":"API","title":"Moma.StateSpace.get_times","text":"get_times(memory::TimeSeriesMemory{T})\n\nExtract the time points from memory as a vector of values.\n\nArguments\n\nmemory::TimeSeriesMemory{T}: The memory to extract times from\n\nReturns\n\nVector of time values\n\n\n\n\n\n","category":"function"},{"location":"api.html#Moma.StateSpace.extend!","page":"API","title":"Moma.StateSpace.extend!","text":"extend!(memory::TimeSeriesMemory{T}, new_time::Object{Float64}, new_state::Object{T}, link::Morphism{T,T})\n\nExtend the memory with a new time point, state, and link between states.\n\nArguments\n\nmemory::TimeSeriesMemory{T}: The memory to extend\nnew_time::Object{Float64}: New time point\nnew_state::Object{T}: New state\nlink::Morphism{T,T}: Link between the previous and new state\n\n\n\n\n\n","category":"function"},{"location":"api.html#Moma.StateSpace.collect_timeseries","page":"API","title":"Moma.StateSpace.collect_timeseries","text":"collect_timeseries(memory::TimeSeriesMemory{T})\n\nCollect the time series data from memory.\n\nArguments\n\nmemory::TimeSeriesMemory{T}: The memory to collect data from\n\nReturns\n\nTuple of (times, states) where times is a vector of Float64 and states is a vector of T\n\n\n\n\n\n","category":"function"},{"location":"api.html#Moma.StateSpace.get_links","page":"API","title":"Moma.StateSpace.get_links","text":"get_links(memory::TimeSeriesMemory{T})\n\nGet the links (morphisms) between consecutive states.\n\nArguments\n\nmemory::TimeSeriesMemory{T}: The memory to extract links from\n\nReturns\n\nVector of morphisms\n\n\n\n\n\n","category":"function"},{"location":"api.html#Type-Parameters","page":"API","title":"Type Parameters","text":"","category":"section"},{"location":"api.html","page":"API","title":"API","text":"Many types in the module are parameterized to allow for flexible data types:","category":"page"},{"location":"api.html","page":"API","title":"API","text":"Object{T}: T can be any type\nMorphism{S,T}: S is the source object's data type, T is the target object's data type\nMemory{T}: T is the type of the state data","category":"page"},{"location":"api.html","page":"API","title":"API","text":"This allows for creating categories with heterogeneous data types while maintaining type safety.","category":"page"},{"location":"api.html#Error-Handling","page":"API","title":"Error Handling","text":"","category":"section"},{"location":"api.html","page":"API","title":"API","text":"Functions in the module may throw the following errors:","category":"page"},{"location":"api.html","page":"API","title":"API","text":"ErrorException: When morphisms are not composable\nErrorException: When objects or morphisms don't belong to a category\nErrorException: When colimit construction fails\nErrorException: When pattern creation fails due to invalid inputs\nErrorException: When simulation parameters are invalid\nErrorException: When plotting data is malformed","category":"page"},{"location":"mes23.html#MES25:-A-Mathematical-Framework-for-Enriching-Human-Machine-Interactions","page":"MES25: A Mathematical Framework for Enriching Human-Machine Interactions","title":"MES25: A Mathematical Framework for Enriching Human-Machine Interactions","text":"","category":"section"},{"location":"mes23.html#Overview","page":"MES25: A Mathematical Framework for Enriching Human-Machine Interactions","title":"Overview","text":"","category":"section"},{"location":"mes23.html","page":"MES25: A Mathematical Framework for Enriching Human-Machine Interactions","title":"MES25: A Mathematical Framework for Enriching Human-Machine Interactions","text":"This paper presents a conceptual mathematical framework for developing rich human-machine interactions to improve decision-making in social organizations. It introduces the concept of a \"multi-level artificial cognitive system\" called a data analyser (DA) that collaborates with humans in data analysis and decision-making processes.","category":"page"},{"location":"mes23.html#Key-Concepts","page":"MES25: A Mathematical Framework for Enriching Human-Machine Interactions","title":"Key Concepts","text":"","category":"section"},{"location":"mes23.html#Data-Analyser-(DA)","page":"MES25: A Mathematical Framework for Enriching Human-Machine Interactions","title":"Data Analyser (DA)","text":"","category":"section"},{"location":"mes23.html","page":"MES25: A Mathematical Framework for Enriching Human-Machine Interactions","title":"MES25: A Mathematical Framework for Enriching Human-Machine Interactions","text":"The DA is designed to:","category":"page"},{"location":"mes23.html","page":"MES25: A Mathematical Framework for Enriching Human-Machine Interactions","title":"MES25: A Mathematical Framework for Enriching Human-Machine Interactions","text":"Collect and analyze data\nLearn and develop autonomous procedures\nAnticipate situations\nDevelop new responses\nImprove decision-making processes","category":"page"},{"location":"mes23.html#Human-Machine-Partnership","page":"MES25: A Mathematical Framework for Enriching Human-Machine Interactions","title":"Human-Machine Partnership","text":"","category":"section"},{"location":"mes23.html","page":"MES25: A Mathematical Framework for Enriching Human-Machine Interactions","title":"MES25: A Mathematical Framework for Enriching Human-Machine Interactions","text":"The framework focuses on:","category":"page"},{"location":"mes23.html","page":"MES25: A Mathematical Framework for Enriching Human-Machine Interactions","title":"MES25: A Mathematical Framework for Enriching Human-Machine Interactions","text":"Collaborative data analysis\nKnowledge extension\nAutonomous learning\nCreation of new procedures\nDeep anticipation capabilities","category":"page"},{"location":"mes23.html#Memory-Evolutive-Systems-Integration","page":"MES25: A Mathematical Framework for Enriching Human-Machine Interactions","title":"Memory Evolutive Systems Integration","text":"","category":"section"},{"location":"mes23.html","page":"MES25: A Mathematical Framework for Enriching Human-Machine Interactions","title":"MES25: A Mathematical Framework for Enriching Human-Machine Interactions","text":"The paper uses MES to describe:","category":"page"},{"location":"mes23.html","page":"MES25: A Mathematical Framework for Enriching Human-Machine Interactions","title":"MES25: A Mathematical Framework for Enriching Human-Machine Interactions","text":"Social organization operations\nDA construction and evolution\nMulti-scale system interactions\nMulti-agent coordination\nMulti-temporality handling","category":"page"},{"location":"mes23.html#Technical-Framework","page":"MES25: A Mathematical Framework for Enriching Human-Machine Interactions","title":"Technical Framework","text":"","category":"section"},{"location":"mes23.html#AI-Integration","page":"MES25: A Mathematical Framework for Enriching Human-Machine Interactions","title":"AI Integration","text":"","category":"section"},{"location":"mes23.html","page":"MES25: A Mathematical Framework for Enriching Human-Machine Interactions","title":"MES25: A Mathematical Framework for Enriching Human-Machine Interactions","text":"The paper discusses:","category":"page"},{"location":"mes23.html","page":"MES25: A Mathematical Framework for Enriching Human-Machine Interactions","title":"MES25: A Mathematical Framework for Enriching Human-Machine Interactions","text":"Historical AI development\nSymbolic AI approaches\nConnectionist paradigms\nIntegration of multiple AI paradigms\nCategory theory applications","category":"page"},{"location":"mes23.html#Implementation-Aspects","page":"MES25: A Mathematical Framework for Enriching Human-Machine Interactions","title":"Implementation Aspects","text":"","category":"section"},{"location":"mes23.html","page":"MES25: A Mathematical Framework for Enriching Human-Machine Interactions","title":"MES25: A Mathematical Framework for Enriching Human-Machine Interactions","text":"Key implementation features:","category":"page"},{"location":"mes23.html","page":"MES25: A Mathematical Framework for Enriching Human-Machine Interactions","title":"MES25: A Mathematical Framework for Enriching Human-Machine Interactions","text":"Multi-level cognitive systems\nRich human-machine interactions\nAnticipatory capabilities\nRisk prevention strategies\nOpportunity identification","category":"page"},{"location":"mes23.html#Applications","page":"MES25: A Mathematical Framework for Enriching Human-Machine Interactions","title":"Applications","text":"","category":"section"},{"location":"mes23.html#Healthcare-Example","page":"MES25: A Mathematical Framework for Enriching Human-Machine Interactions","title":"Healthcare Example","text":"","category":"section"},{"location":"mes23.html","page":"MES25: A Mathematical Framework for Enriching Human-Machine Interactions","title":"MES25: A Mathematical Framework for Enriching Human-Machine Interactions","text":"Demonstrates DA implementation in:","category":"page"},{"location":"mes23.html","page":"MES25: A Mathematical Framework for Enriching Human-Machine Interactions","title":"MES25: A Mathematical Framework for Enriching Human-Machine Interactions","text":"Symptom detection\nAutonomous response selection\nDecision-making participation\nCommunication improvement\nMisunderstanding detection","category":"page"},{"location":"mes23.html#General-Applications","page":"MES25: A Mathematical Framework for Enriching Human-Machine Interactions","title":"General Applications","text":"","category":"section"},{"location":"mes23.html","page":"MES25: A Mathematical Framework for Enriching Human-Machine Interactions","title":"MES25: A Mathematical Framework for Enriching Human-Machine Interactions","text":"The framework can be applied to:","category":"page"},{"location":"mes23.html","page":"MES25: A Mathematical Framework for Enriching Human-Machine Interactions","title":"MES25: A Mathematical Framework for Enriching Human-Machine Interactions","text":"Social organizations\nHealthcare institutions\nEducational systems\nBusiness environments\nComplex decision-making scenarios","category":"page"},{"location":"mes23.html#Future-Directions","page":"MES25: A Mathematical Framework for Enriching Human-Machine Interactions","title":"Future Directions","text":"","category":"section"},{"location":"mes23.html","page":"MES25: A Mathematical Framework for Enriching Human-Machine Interactions","title":"MES25: A Mathematical Framework for Enriching Human-Machine Interactions","text":"The paper suggests development paths for:","category":"page"},{"location":"mes23.html","page":"MES25: A Mathematical Framework for Enriching Human-Machine Interactions","title":"MES25: A Mathematical Framework for Enriching Human-Machine Interactions","text":"Third-generation AI systems\nEnhanced human-machine collaboration\nImproved anticipatory capabilities\nRisk prevention mechanisms\nDecision-making optimization ","category":"page"},{"location":"moma25.html#MoMa25:-Monetary-Macro-Accounting-Theory","page":"MoMa25: Monetary Macro Accounting Theory","title":"MoMa25: Monetary Macro Accounting Theory","text":"","category":"section"},{"location":"moma25.html#Overview","page":"MoMa25: Monetary Macro Accounting Theory","title":"Overview","text":"","category":"section"},{"location":"moma25.html","page":"MoMa25: Monetary Macro Accounting Theory","title":"MoMa25: Monetary Macro Accounting Theory","text":"This paper develops a specification for software for macro accounting (MoMa) and a monetary macro accounting theory (MoMaT). It presents a novel approach where money functions as a medium of payment for obligations and debts, rather than just a medium of exchange.","category":"page"},{"location":"moma25.html#Key-Concepts","page":"MoMa25: Monetary Macro Accounting Theory","title":"Key Concepts","text":"","category":"section"},{"location":"moma25.html#Theoretical-Framework","page":"MoMa25: Monetary Macro Accounting Theory","title":"Theoretical Framework","text":"","category":"section"},{"location":"moma25.html","page":"MoMa25: Monetary Macro Accounting Theory","title":"MoMa25: Monetary Macro Accounting Theory","text":"The paper addresses:","category":"page"},{"location":"moma25.html","page":"MoMa25: Monetary Macro Accounting Theory","title":"MoMa25: Monetary Macro Accounting Theory","text":"Temporal misalignment in production\nLegal principles of Separation and Abstraction\nDebt, contracts, and property rights\nMulti-level monetary systems analysis","category":"page"},{"location":"moma25.html#System-Levels","page":"MoMa25: Monetary Macro Accounting Theory","title":"System Levels","text":"","category":"section"},{"location":"moma25.html","page":"MoMa25: Monetary Macro Accounting Theory","title":"MoMa25: Monetary Macro Accounting Theory","text":"The monetary system operates at three interconnected levels:","category":"page"},{"location":"moma25.html","page":"MoMa25: Monetary Macro Accounting Theory","title":"MoMa25: Monetary Macro Accounting Theory","text":"Micro Level: Division of labor facilitation\nMeso Level: Risk sharing in banking\nMacro Level: GDP distribution through issued money","category":"page"},{"location":"moma25.html#Core-Components","page":"MoMa25: Monetary Macro Accounting Theory","title":"Core Components","text":"","category":"section"},{"location":"moma25.html#Bill-of-Exchange-(BoE)","page":"MoMa25: Monetary Macro Accounting Theory","title":"Bill of Exchange (BoE)","text":"","category":"section"},{"location":"moma25.html","page":"MoMa25: Monetary Macro Accounting Theory","title":"MoMa25: Monetary Macro Accounting Theory","text":"Serves as:","category":"page"},{"location":"moma25.html","page":"MoMa25: Monetary Macro Accounting Theory","title":"MoMa25: Monetary Macro Accounting Theory","text":"Unifying instrument\nBridge between debt processes\nMoney issuing mechanism\nConnection between fiat and gold-based systems","category":"page"},{"location":"moma25.html#Mathematical-Foundations","page":"MoMa25: Monetary Macro Accounting Theory","title":"Mathematical Foundations","text":"","category":"section"},{"location":"moma25.html","page":"MoMa25: Monetary Macro Accounting Theory","title":"MoMa25: Monetary Macro Accounting Theory","text":"Utilizes:","category":"page"},{"location":"moma25.html","page":"MoMa25: Monetary Macro Accounting Theory","title":"MoMa25: Monetary Macro Accounting Theory","text":"Sheaf theory for accounting invariances\nHomology theory for monetary policy\nOpen Games for computation\nMulti-agent model analysis","category":"page"},{"location":"moma25.html#Applications","page":"MoMa25: Monetary Macro Accounting Theory","title":"Applications","text":"","category":"section"},{"location":"moma25.html#Supply-Chain-Finance","page":"MoMa25: Monetary Macro Accounting Theory","title":"Supply Chain Finance","text":"","category":"section"},{"location":"moma25.html","page":"MoMa25: Monetary Macro Accounting Theory","title":"MoMa25: Monetary Macro Accounting Theory","text":"Debt networks analysis\nPayment systems integration\nRisk distribution mechanisms\nFinancial obligation tracking","category":"page"},{"location":"moma25.html#Monetary-Policy","page":"MoMa25: Monetary Macro Accounting Theory","title":"Monetary Policy","text":"","category":"section"},{"location":"moma25.html","page":"MoMa25: Monetary Macro Accounting Theory","title":"MoMa25: Monetary Macro Accounting Theory","text":"Central banking operations\nMoney circulation analysis\nDebt vortices study\nFinancial obligation resolution","category":"page"},{"location":"moma25.html#Technical-Implementation","page":"MoMa25: Monetary Macro Accounting Theory","title":"Technical Implementation","text":"","category":"section"},{"location":"moma25.html#Software-Components","page":"MoMa25: Monetary Macro Accounting Theory","title":"Software Components","text":"","category":"section"},{"location":"moma25.html","page":"MoMa25: Monetary Macro Accounting Theory","title":"MoMa25: Monetary Macro Accounting Theory","text":"MoMa implementation can include:","category":"page"},{"location":"moma25.html","page":"MoMa25: Monetary Macro Accounting Theory","title":"MoMa25: Monetary Macro Accounting Theory","text":"Macro accounting systems\nSmart contracts\nStructural econometric models\nData analysis tools","category":"page"},{"location":"moma25.html#Mathematical-Tools","page":"MoMa25: Monetary Macro Accounting Theory","title":"Mathematical Tools","text":"","category":"section"},{"location":"moma25.html","page":"MoMa25: Monetary Macro Accounting Theory","title":"MoMa25: Monetary Macro Accounting Theory","text":"Proposes:","category":"page"},{"location":"moma25.html","page":"MoMa25: Monetary Macro Accounting Theory","title":"MoMa25: Monetary Macro Accounting Theory","text":"Category theory\nSheaf theory like MES colimits\nHomology theory like MES coregulators\nGame theory","category":"page"},{"location":"moma25.html#Future-Implications","page":"MoMa25: Monetary Macro Accounting Theory","title":"Future Implications","text":"","category":"section"},{"location":"moma25.html","page":"MoMa25: Monetary Macro Accounting Theory","title":"MoMa25: Monetary Macro Accounting Theory","text":"The framework provides foundations for:","category":"page"},{"location":"moma25.html","page":"MoMa25: Monetary Macro Accounting Theory","title":"MoMa25: Monetary Macro Accounting Theory","text":"Macro economic research in monetary systems\nDigital currency development, like stable coins\nReal estate management \nRenewable energy management systems, virtual power plants\nEconomic policy making ","category":"page"},{"location":"examples.html#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples.html","page":"Examples","title":"Examples","text":"This section provides practical examples of using the Moma package for various applications.","category":"page"},{"location":"examples.html#Geometric-System","page":"Examples","title":"Geometric System","text":"","category":"section"},{"location":"examples.html","page":"Examples","title":"Examples","text":"more...","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"Implementation with custom data types (Point, Line)\nStructured representation of geometric objects and transformations\nComposition of geometric transformations using morphisms\nPossible extensions\nPreservation of geometric invariants through categorical framework\nPattern recognition in geometric structures\nHierarchical organization of complex geometric systems\nCategory and pattern construction for geometric configurations","category":"page"},{"location":"examples.html#Error-Handling","page":"Examples","title":"Error Handling","text":"","category":"section"},{"location":"examples.html","page":"Examples","title":"Examples","text":"...more","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"Comprehensive error checking for categorical laws\nEdge case handling and validation\nBest practices for robust error management\nPossible extensions:\nSelf-healing systems based on MES concepts\nHierarchical error handling with different time scales\nCo-regulator pattern for specialized error handling\nMemory-based recovery using system links","category":"page"},{"location":"papers.html#Papers","page":"Papers","title":"Papers","text":"","category":"section"},{"location":"papers.html","page":"Papers","title":"Papers","text":"This section provides an overview of the papers that form the theoretical foundation of the MoMa package.","category":"page"},{"location":"papers.html#MoMa25:-Monetary-Macro-Accounting","page":"Papers","title":"MoMa25: Monetary Macro Accounting","text":"","category":"section"},{"location":"papers.html","page":"Papers","title":"Papers","text":"Summary, pdf","category":"page"},{"location":"papers.html","page":"Papers","title":"Papers","text":"MoMa25 develops a specification for software for macro accounting (MoMa) and a monetary macro accounting theory (MoMaT). The paper presents a novel approach where money functions as a medium of payment for obligations and debts, rather than just a medium of exchange. It addresses temporal misalignment in production, legal principles of Separation and Abstraction, and debt management through a three-level system: micro (division of labor), meso (banking risk sharing), and macro (GDP distribution). The paper proposes and argues why to use mathematical tools including sheaf theory for accounting invariances, homology theory for monetary policy, and open games for computation, with applications in supply chain finance, monetary policy, renewable energy models, or digital currency development.","category":"page"},{"location":"papers.html","page":"Papers","title":"Papers","text":"A MoMa Simulation in Julia of a National Accounting is in src/original_moma directory contains several files used for generating and checking simulation data underlying the MoMa paper. In file momascf_v02_en.jl is a simulation of the following basic MoMa macro accounting structure.","category":"page"},{"location":"papers.html","page":"Papers","title":"Papers","text":"(Image: Basic National Accounting Structure) ","category":"page"},{"location":"papers.html#MES23:-Human–Machine-Interactions","page":"Papers","title":"MES23: Human–Machine Interactions","text":"","category":"section"},{"location":"papers.html","page":"Papers","title":"Papers","text":"Summary, pdf","category":"page"},{"location":"papers.html","page":"Papers","title":"Papers","text":"MES23 applies the Memory Evolutive Systems framework to analyze human-machine interactions in complex systems. The paper explores how multiple agents with different temporalities can cooperate effectively, focusing on the synchronization and coordination challenges that arise in human-machine systems. It provides insights into designing more effective collaborative systems where humans and machines work together, taking into account their different processing speeds and decision-making capabilities.","category":"page"},{"location":"papers.html#MES07:-Memory-Evolutive-Systems","page":"Papers","title":"MES07: Memory Evolutive Systems","text":"","category":"section"},{"location":"papers.html","page":"Papers","title":"Papers","text":"Summary, pdf","category":"page"},{"location":"papers.html","page":"Papers","title":"Papers","text":"MES07 presents a comprehensive mathematical framework for modeling complex evolutionary systems using category theory. The paper introduces Memory Evolutive Systems (MES) as a theoretical foundation for understanding how biological, cognitive, and social systems develop and adapt over time. It explains how multiple hierarchical components interact and evolve, incorporating concepts such as emergence, complexity, and time-scaling. The framework is particularly valuable for modeling systems with multiple interconnected levels of organization, memory formation, and adaptive behavior.","category":"page"},{"location":"papers.html","page":"Papers","title":"Papers","text":"A comprehensive synthesis of two decades of research on memory evolutive systems, presenting mathematical models for autonomous evolutionary systems such as biological, social, and nervous systems.","category":"page"},{"location":"index.html#Central-Banks-for-All-and-Everything","page":"Home","title":"Central Banks for All and Everything","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"This Julia package implements a Monetary Macro Accounting (MoMa) system of Menéndez and Winschel. It is modeled with categorical tools of Memory Evolutive Systems (MES) of Ehresmann and Vanbremeersch. By that we can model multi-level, hierarchical systems like micro, meso and macro economies are.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"The monetary theory of MoMa works for national accounting, sectors and companies but also for within companies as holdings with subsidiaries and down to smaller levels like to processes of a box ordering screws. MoMa is a multi-level accounting theory for macro accounting with different time scales extending micro accounting aka double-entry bookkeeping.  This then is the beginning of composable enterprises and a new generation of ERP systems,  then EcRP systems for economic resource planing.","category":"page"},{"location":"index.html#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"This documentation contain implementations and","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Basic category theoretical constructions\nA statespace model implementation with categorical and MES tools\nBasic simulation of a MoMa national accounting\nSummaries and pdfs of MES and MoMa","category":"page"},{"location":"index.html#Documentation-Sections","page":"Home","title":"Documentation Sections","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Categories: Introduction to category theory concepts\nState Space Models: Implementation of state space models using MES\nExamples: Usage examples and tutorials\nPapers: Related academic papers and references\nAPI: Detailed API documentation","category":"page"},{"location":"index.html#Quick-Start","page":"Home","title":"Quick Start","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"using Moma\n\n# Create objects and morphisms\nA = Object(:A, \"data\")\nB = Object(:B, \"DATA\")\nf = Morphism(A, B, uppercase, :f)\n\n# Create a category\nC = Category([A, B], [f], :C)\n\n# Create and simulate a state space model\nt₁, s₁, time_step, evolution = create_ar_model([0.5])\nmemory = simulate_dynamics(t₁, s₁, time_step, evolution, 100)","category":"page"},{"location":"index.html#Contributing","page":"Home","title":"Contributing","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Contributions are welcome! by email to repository owner","category":"page"}]
}
