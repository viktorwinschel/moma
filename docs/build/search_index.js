var documenterSearchIndex = {"docs":
[{"location":"api.html#API-Reference","page":"API","title":"API Reference","text":"","category":"section"},{"location":"api.html#Overview","page":"API","title":"Overview","text":"","category":"section"},{"location":"api.html","page":"API","title":"API","text":"The Categories module provides implementations of fundamental category theory concepts used in Memory Evolutive Systems (MES). This includes:","category":"page"},{"location":"api.html","page":"API","title":"API","text":"Basic categorical constructions (objects, morphisms, categories)\nFunctorial mappings between categories\nNatural transformations between functors\nPattern (diagram) creation and manipulation\nColimit computation and verification","category":"page"},{"location":"api.html#Modules","page":"API","title":"Modules","text":"","category":"section"},{"location":"api.html","page":"API","title":"API","text":"Modules = [Moma.Categories]\nOrder = [:module]","category":"page"},{"location":"api.html#Moma.Categories","page":"API","title":"Moma.Categories","text":"module Categories\n\nThis module provides basic categorical constructions used in Memory Evolutive Systems (MES). It includes implementations of objects, morphisms, categories, functors, natural transformations, and patterns, along with functions for working with these constructions.\n\nMathematical Background\n\nThe module implements core concepts from category theory:\n\nObjects and morphisms form categories with composition and identity laws\nFunctors preserve structure between categories\nNatural transformations connect functors\nColimits represent universal constructions\n\nExports\n\nObject: Represents an object in a category\nMorphism: Represents a morphism between objects\nCategory: Represents a category with objects and morphisms\nFunctor: Represents a functor between categories\nNaturalTransformation: Represents a natural transformation between functors\nPattern: Represents a pattern (diagram) in a category\nidentity: Creates an identity morphism for an object\ncompose: Composes two morphisms\ncreate_pattern: Creates a pattern from objects and morphisms\ncheck_binding: Checks if an object forms a colimit for a pattern\nfind_colimit: Finds or constructs colimits for patterns\nis_morphism_in_category: Checks if a morphism belongs to a category\n\n\n\n\n\n","category":"module"},{"location":"api.html#Types","page":"API","title":"Types","text":"","category":"section"},{"location":"api.html#Basic-Types","page":"API","title":"Basic Types","text":"","category":"section"},{"location":"api.html","page":"API","title":"API","text":"Moma.Categories.Object\nMoma.Categories.Morphism\nMoma.Categories.Category","category":"page"},{"location":"api.html#Moma.Categories.Object","page":"API","title":"Moma.Categories.Object","text":"Object{T}\n\nRepresents an object in a category.\n\nType Parameters\n\nT: The type of data associated with the object\n\nFields\n\nid::Symbol: Unique identifier for the object\ndata::T: Data associated with the object\n\nExamples\n\n# Create an object with string data\nobj = Object(:A, \"data\")\n\n# Create an object with numeric data\nnum_obj = Object(:B, 42)\n\n# Create an object with custom type\nstruct Point\n    x::Float64\n    y::Float64\nend\npoint_obj = Object(:P, Point(0.0, 1.0))\n\n\n\n\n\n","category":"type"},{"location":"api.html#Moma.Categories.Morphism","page":"API","title":"Moma.Categories.Morphism","text":"Morphism{S,T}\n\nRepresents a morphism between objects in a category.\n\nType Parameters\n\nS: The type of data in the source object\nT: The type of data in the target object\n\nFields\n\nsource::Object{S}: Source object\ntarget::Object{T}: Target object\nmap::Function: Function mapping source to target\nid::Symbol: Unique identifier for the morphism\n\nExamples\n\n# Create objects\nA = Object(:A, \"hello\")\nB = Object(:B, \"HELLO\")\n\n# Create a morphism that uppercases strings\nf = Morphism(A, B, uppercase, :f)\n@assert f.map(A.data) == B.data\n\n# Create a morphism between numeric objects\nX = Object(:X, 1)\nY = Object(:Y, 2)\ng = Morphism(X, Y, x -> x + 1, :g)\n\n\n\n\n\n","category":"type"},{"location":"api.html#Moma.Categories.Category","page":"API","title":"Moma.Categories.Category","text":"Category\n\nRepresents a category with objects and morphisms.\n\nFields\n\nobjects::Vector{<:Object}: Objects in the category\nmorphisms::Vector{<:Morphism}: Morphisms in the category\nid::Symbol: Unique identifier for the category\n\n\n\n\n\n","category":"type"},{"location":"api.html#Advanced-Types","page":"API","title":"Advanced Types","text":"","category":"section"},{"location":"api.html","page":"API","title":"API","text":"Moma.Categories.Functor\nMoma.Categories.NaturalTransformation\nMoma.Categories.Pattern","category":"page"},{"location":"api.html#Moma.Categories.Functor","page":"API","title":"Moma.Categories.Functor","text":"Functor\n\nRepresents a functor between categories.\n\nFields\n\nsource::Category: Source category\ntarget::Category: Target category\nobject_map::Dict{<:Object,<:Object}: Mapping of objects\nmorphism_map::Dict{<:Morphism,<:Morphism}: Mapping of morphisms\nid::Symbol: Unique identifier for the functor\n\n\n\n\n\n","category":"type"},{"location":"api.html#Moma.Categories.NaturalTransformation","page":"API","title":"Moma.Categories.NaturalTransformation","text":"NaturalTransformation\n\nRepresents a natural transformation between functors.\n\nFields\n\nsource::Functor: Source functor\ntarget::Functor: Target functor\ncomponents::Dict{<:Object,<:Morphism}: Component morphisms\nid::Symbol: Unique identifier for the natural transformation\n\n\n\n\n\n","category":"type"},{"location":"api.html#Moma.Categories.Pattern","page":"API","title":"Moma.Categories.Pattern","text":"Pattern\n\nRepresents a pattern (diagram) in a category.\n\nFields\n\ncategory::Category: The category containing the pattern\nobjects::Vector{<:Object}: Objects in the pattern\nmorphisms::Vector{<:Morphism}: Morphisms in the pattern\nid::Symbol: Unique identifier for the pattern\n\n\n\n\n\n","category":"type"},{"location":"api.html#Functions","page":"API","title":"Functions","text":"","category":"section"},{"location":"api.html#Basic-Operations","page":"API","title":"Basic Operations","text":"","category":"section"},{"location":"api.html","page":"API","title":"API","text":"Moma.Categories.identity\nMoma.Categories.compose\nMoma.Categories.is_morphism_in_category","category":"page"},{"location":"api.html#Moma.Categories.identity","page":"API","title":"Moma.Categories.identity","text":"identity(obj::Object)\n\nCreate an identity morphism for an object.\n\nArguments\n\nobj::Object: The object to create an identity morphism for\n\nReturns\n\nMorphism: A morphism from the object to itself with the identity function\n\nExamples\n\nA = Object(:A, \"data\")\nid_A = identity(A)\n@assert id_A.map(A.data) == A.data\n\n\n\n\n\n","category":"function"},{"location":"api.html#Moma.Categories.compose","page":"API","title":"Moma.Categories.compose","text":"compose(f::Morphism, g::Morphism)\n\nCompose two morphisms if they are composable (target of f equals source of g).\n\nArguments\n\nf::Morphism{S,T}: First morphism\ng::Morphism{T,U}: Second morphism\n\nReturns\n\nMorphism{S,U}: The composition g ∘ f\n\nThrows\n\nErrorException: If the morphisms are not composable (f.target ≠ g.source)\n\nExamples\n\n# Create objects and morphisms\nA = Object(:A, \"hello\")\nB = Object(:B, \"HELLO\")\nC = Object(:C, \"HELLO!\")\nf = Morphism(A, B, uppercase, :f)\ng = Morphism(B, C, s -> s * \"!\", :g)\n\n# Compose morphisms\nh = compose(f, g)\n@assert h.map(\"hello\") == \"HELLO!\"\n\n# This will throw an error\nk = Morphism(C, A, lowercase, :k)\ncompose(f, k)  # Error: Morphisms are not composable\n\n\n\n\n\n","category":"function"},{"location":"api.html#Moma.Categories.is_morphism_in_category","page":"API","title":"Moma.Categories.is_morphism_in_category","text":"is_morphism_in_category(morphism::Morphism, category::Category)\n\nCheck if a morphism belongs to a category.\n\nArguments\n\nmorphism::Morphism: The morphism to check\ncategory::Category: The category to check against\n\nReturns\n\nBool: true if the morphism belongs to the category, false otherwise\n\nExamples\n\n# Create objects and a morphism\nA = Object(:A, 1)\nB = Object(:B, 2)\nf = Morphism(A, B, x -> x + 1, :f)\n\n# Create a category and check membership\nC = Category([A, B], [f], :C)\n@assert is_morphism_in_category(f, C)\n\n# Check a morphism not in the category\ng = Morphism(B, A, x -> x - 1, :g)\n@assert !is_morphism_in_category(g, C)\n\n\n\n\n\n","category":"function"},{"location":"api.html#Pattern-and-Colimit-Operations","page":"API","title":"Pattern and Colimit Operations","text":"","category":"section"},{"location":"api.html","page":"API","title":"API","text":"Moma.Categories.create_pattern\nMoma.Categories.check_binding\nMoma.Categories.find_colimit","category":"page"},{"location":"api.html#Moma.Categories.create_pattern","page":"API","title":"Moma.Categories.create_pattern","text":"create_pattern(category::Category, objects::Vector{<:Object}, morphisms::Vector{<:Morphism})\n\nCreate a pattern (diagram) from a subset of objects and morphisms in a category.\n\nArguments\n\ncategory::Category: The category containing the objects and morphisms\nobjects::Vector{<:Object}: Objects to include in the pattern\nmorphisms::Vector{<:Morphism}: Morphisms to include in the pattern\n\nReturns\n\nPattern: A new pattern containing the specified objects and morphisms\n\nThrows\n\nErrorException: If any object or morphism does not belong to the category\n\nExamples\n\n# Create objects and morphisms\nA = Object(:A, 1)\nB = Object(:B, 2)\nf = Morphism(A, B, x -> x + 1, :f)\n\n# Create category and pattern\nC = Category([A, B], [f], :C)\nP = create_pattern(C, [A, B], [f])\n\n# This will throw an error\nX = Object(:X, 0)\ncreate_pattern(C, [A, X], [f])  # Error: Objects must belong to the category\n\n\n\n\n\n","category":"function"},{"location":"api.html#Moma.Categories.check_binding","page":"API","title":"Moma.Categories.check_binding","text":"check_binding(object::Object, bindings::Dict{<:Object,<:Morphism}, pattern::Pattern)\n\nCheck if an object with specified bindings forms a colimit for a pattern.\n\nArguments\n\nobject::Object: The candidate colimit object\nbindings::Dict{<:Object,<:Morphism}: Morphisms from pattern objects to the candidate\npattern::Pattern: The pattern to check\n\nReturns\n\nBool: true if the object with bindings forms a colimit, false otherwise\n\nMathematical Description\n\nFor a pattern P and an object C with bindings b, this checks if C is a colimit by verifying:\n\nEvery object in P has a binding morphism to C\nAll diagrams commute: For any morphism f: X → Y in P, bY ∘ f = bX\n\nwhere bX and bY are the binding morphisms for X and Y respectively.\n\nExamples\n\n# Create a simple pattern\nA = Object(:A, 1)\nB = Object(:B, 2)\nf = Morphism(A, B, x -> x + 1, :f)\nC = Category([A, B], [f], :C)\nP = create_pattern(C, [A, B], [f])\n\n# Create bindings to a candidate colimit\ncolimit = Object(:Col, [1, 2])\nbindings = Dict(\n    A => Morphism(A, colimit, x -> [x, x+1], :bA),\n    B => Morphism(B, colimit, x -> [x-1, x], :bB)\n)\n\n# Check if it forms a colimit\nis_colimit = check_binding(colimit, bindings, P)\n\n\n\n\n\n","category":"function"},{"location":"api.html#Moma.Categories.find_colimit","page":"API","title":"Moma.Categories.find_colimit","text":"find_colimit(pattern::Pattern)\n\nFind or construct a colimit for a pattern.\n\nArguments\n\npattern::Pattern: The pattern to find a colimit for\n\nReturns\n\nTuple{Object,Dict{<:Object,<:Morphism}}: A tuple containing:\nThe colimit object\nA dictionary mapping pattern objects to their binding morphisms\n\nDescription\n\nThis function constructs a colimit by:\n\nCreating a candidate object that combines data from all pattern objects\nConstructing appropriate morphisms from pattern objects to the candidate\nVerifying the colimit properties\n\nMathematical Background\n\nA colimit is a universal cocone over a diagram. For a pattern P, it consists of:\n\nAn object C (the colimit object)\nA family of morphisms bi: Pi → C (the binding morphisms)\n\nsuch that:\n\nAll diagrams commute\nFor any other cocone (D, h_i), there exists a unique morphism u: C → D making all triangles commute\n\nExamples\n\n# Create a simple pattern\nA = Object(:A, 1)\nB = Object(:B, 2)\nf = Morphism(A, B, x -> x + 1, :f)\nC = Category([A, B], [f], :C)\nP = create_pattern(C, [A, B], [f])\n\n# Find its colimit\ncolimit_obj, bindings = find_colimit(P)\n@assert colimit_obj.data == [1, 2]  # Combined data\n@assert check_binding(colimit_obj, bindings, P)  # Verify it's a colimit\n\nThrows\n\nErrorException: If a valid colimit cannot be constructed\n\n\n\n\n\n","category":"function"},{"location":"api.html#Type-Parameters","page":"API","title":"Type Parameters","text":"","category":"section"},{"location":"api.html","page":"API","title":"API","text":"Many types in the module are parameterized to allow for flexible data types:","category":"page"},{"location":"api.html","page":"API","title":"API","text":"Object{T}: T can be any type\nMorphism{S,T}: S is the source object's data type, T is the target object's data type","category":"page"},{"location":"api.html","page":"API","title":"API","text":"This allows for creating categories with heterogeneous data types while maintaining type safety.","category":"page"},{"location":"api.html#Error-Handling","page":"API","title":"Error Handling","text":"","category":"section"},{"location":"api.html","page":"API","title":"API","text":"Functions in the module may throw the following errors:","category":"page"},{"location":"api.html","page":"API","title":"API","text":"ErrorException: When morphisms are not composable\nErrorException: When objects or morphisms don't belong to a category\nErrorException: When colimit construction fails\nErrorException: When pattern creation fails due to invalid inputs","category":"page"},{"location":"api.html","page":"API","title":"API","text":"For more detailed mathematical background, see the Papers section. ","category":"page"},{"location":"mes07.html#MES07:-Memory-Evolutive-Systems","page":"MES07: Memory Evolutive Systems","title":"MES07: Memory Evolutive Systems","text":"","category":"section"},{"location":"mes07.html#Overview","page":"MES07: Memory Evolutive Systems","title":"Overview","text":"","category":"section"},{"location":"mes07.html","page":"MES07: Memory Evolutive Systems","title":"MES07: Memory Evolutive Systems","text":"This foundational paper introduces Memory Evolutive Systems (MES) as mathematical models for autonomous evolutionary systems, particularly focusing on biological and social systems, including nervous systems of higher animals. The work is rooted in category theory and represents two decades of research development.","category":"page"},{"location":"mes07.html#Key-Concepts","page":"MES07: Memory Evolutive Systems","title":"Key Concepts","text":"","category":"section"},{"location":"mes07.html#Complexity-Characterization","page":"MES07: Memory Evolutive Systems","title":"Complexity Characterization","text":"","category":"section"},{"location":"mes07.html","page":"MES07: Memory Evolutive Systems","title":"MES07: Memory Evolutive Systems","text":"The paper addresses three fundamental problems:","category":"page"},{"location":"mes07.html","page":"MES07: Memory Evolutive Systems","title":"MES07: Memory Evolutive Systems","text":"The Binding Problem: How simple objects combine to form a \"whole greater than the sum of its parts\"\nThe Emergence Problem: How properties of complex objects relate to their elementary components\nThe Hierarchy Problem: Explaining the formation of increasingly complex objects, from elementary particles to societies","category":"page"},{"location":"mes07.html#Self-Regulation","page":"MES07: Memory Evolutive Systems","title":"Self-Regulation","text":"","category":"section"},{"location":"mes07.html","page":"MES07: Memory Evolutive Systems","title":"MES07: Memory Evolutive Systems","text":"The paper introduces key characteristics that allow for autonomy through self-regulation:","category":"page"},{"location":"mes07.html","page":"MES07: Memory Evolutive Systems","title":"MES07: Memory Evolutive Systems","text":"Internal regulation systems\nCapacity to recognize environmental characteristics\nDevelopment of appropriate responses\nIntroduction of co-regulators (CR) for different hierarchy levels\nFlexible memory systems for adaptation","category":"page"},{"location":"mes07.html#Cognitive-Systems","page":"MES07: Memory Evolutive Systems","title":"Cognitive Systems","text":"","category":"section"},{"location":"mes07.html","page":"MES07: Memory Evolutive Systems","title":"MES07: Memory Evolutive Systems","text":"The paper explores applications to:","category":"page"},{"location":"mes07.html","page":"MES07: Memory Evolutive Systems","title":"MES07: Memory Evolutive Systems","text":"Nervous system modeling\nCognition processes\nConsciousness modeling\nDevelopment of personal memory (archetypal core)","category":"page"},{"location":"mes07.html#Mathematical-Framework","page":"MES07: Memory Evolutive Systems","title":"Mathematical Framework","text":"","category":"section"},{"location":"mes07.html","page":"MES07: Memory Evolutive Systems","title":"MES07: Memory Evolutive Systems","text":"The model uses:","category":"page"},{"location":"mes07.html","page":"MES07: Memory Evolutive Systems","title":"MES07: Memory Evolutive Systems","text":"Category theory as the foundational mathematical structure\nComplex systems theory\nHierarchical evolutive systems based on colimit concepts\nNetwork theory for co-regulator interactions","category":"page"},{"location":"mes07.html#Applications","page":"MES07: Memory Evolutive Systems","title":"Applications","text":"","category":"section"},{"location":"mes07.html","page":"MES07: Memory Evolutive Systems","title":"MES07: Memory Evolutive Systems","text":"The framework has applications in:","category":"page"},{"location":"mes07.html","page":"MES07: Memory Evolutive Systems","title":"MES07: Memory Evolutive Systems","text":"Biology\nMedicine\nSociology\nEcology\nEconomics\nComplex systems analysis","category":"page"},{"location":"mes07.html#Historical-Context","page":"MES07: Memory Evolutive Systems","title":"Historical Context","text":"","category":"section"},{"location":"mes07.html","page":"MES07: Memory Evolutive Systems","title":"MES07: Memory Evolutive Systems","text":"The work emerged from a collaboration between:","category":"page"},{"location":"mes07.html","page":"MES07: Memory Evolutive Systems","title":"MES07: Memory Evolutive Systems","text":"Jean-Paul Vanbremeersch (physician specializing in gerontology)\nAndrée C. Ehresmann (mathematician)","category":"page"},{"location":"mes07.html","page":"MES07: Memory Evolutive Systems","title":"MES07: Memory Evolutive Systems","text":"Their collaboration began in 1980, leading to the development of MES theory.","category":"page"},{"location":"category_theory.html#Category-Theory","page":"Category Theory","title":"Category Theory","text":"","category":"section"},{"location":"category_theory.html","page":"Category Theory","title":"Category Theory","text":"This section provides a mathematical introduction to the category theory concepts implemented in MoMa.","category":"page"},{"location":"category_theory.html#Categories","page":"Category Theory","title":"Categories","text":"","category":"section"},{"location":"category_theory.html#Mathematical-Definition","page":"Category Theory","title":"Mathematical Definition","text":"","category":"section"},{"location":"category_theory.html","page":"Category Theory","title":"Category Theory","text":"A category mathcalC consists of:","category":"page"},{"location":"category_theory.html","page":"Category Theory","title":"Category Theory","text":"A collection of objects textOb(mathcalC)\nA collection of morphisms textHom(mathcalC), where each morphism f A to B has a source A and target B\nFor each object A, an identity morphism textid_A A to A\nA composition operation circ textHom(BC) times textHom(AB) to textHom(AC) that satisfies:\nAssociativity: (h circ g) circ f = h circ (g circ f) forall f A to B g B to C h C to D\nIdentity: f circ textid_A = f = textid_B circ f forall f A to B","category":"page"},{"location":"category_theory.html","page":"Category Theory","title":"Category Theory","text":"For a detailed theoretical background on categories, see MES23: Categories and Functors.","category":"page"},{"location":"category_theory.html","page":"Category Theory","title":"Category Theory","text":"beginCD\nA f B g C \nVtextid_AVV Vtextid_BVV Vtextid_CVV \nA f B g C\nendCD","category":"page"},{"location":"category_theory.html#Implementation","page":"Category Theory","title":"Implementation","text":"","category":"section"},{"location":"category_theory.html","page":"Category Theory","title":"Category Theory","text":"In MoMa, categories are implemented using the following types:","category":"page"},{"location":"category_theory.html","page":"Category Theory","title":"Category Theory","text":"Object (lines 61-65)\nMorphism (lines 97-102)\nCategory (lines 114-118)\nidentity (lines 194-196)\ncompose (lines 231-237)","category":"page"},{"location":"category_theory.html","page":"Category Theory","title":"Category Theory","text":"# Implementation in Categories.jl\nstruct Object{T}\n    name::Symbol\n    data::T\nend\n\nstruct Morphism{S,T}\n    source::Object{S}\n    target::Object{T}\n    map::Function\n    name::Symbol\nend\n\nstruct Category\n    objects::Vector{Object}\n    morphisms::Vector{Morphism}\n    name::Symbol\nend","category":"page"},{"location":"category_theory.html","page":"Category Theory","title":"Category Theory","text":"For comprehensive tests of these implementations, see the test files in the repository.","category":"page"},{"location":"category_theory.html#Examples","page":"Category Theory","title":"Examples","text":"","category":"section"},{"location":"category_theory.html","page":"Category Theory","title":"Category Theory","text":"The following examples demonstrate the basic usage:","category":"page"},{"location":"category_theory.html","page":"Category Theory","title":"Category Theory","text":"using Moma.Categories\n\n# Examples from Categories.jl docstrings and tests\nA = Object(:A, \"hello\")           # String data\nB = Object(:B, 42)               # Integer data\nC = Object(:C, Point(0.0, 1.0))  # Custom type data\n\n# Create morphisms with explicit functions\nf = Morphism(A, Object(:B, \"HELLO\"), uppercase, :f)\ng = Morphism(B, Object(:C, 43), x -> x + 1, :g)\n\n# Create identity morphisms\nid_A = identity(A)\n@assert id_A.map(\"hello\") == \"hello\"\n\n# Compose compatible morphisms\nh = compose(\n    Morphism(A, B, x -> length(x), :h),\n    Morphism(B, C, x -> Point(float(x), 0.0), :i)\n)","category":"page"},{"location":"category_theory.html","page":"Category Theory","title":"Category Theory","text":"For more complex examples and edge cases, see the test files in the repository.","category":"page"},{"location":"category_theory.html#Functors","page":"Category Theory","title":"Functors","text":"","category":"section"},{"location":"category_theory.html#Mathematical-Definition-2","page":"Category Theory","title":"Mathematical Definition","text":"","category":"section"},{"location":"category_theory.html","page":"Category Theory","title":"Category Theory","text":"A functor F mathcalC to mathcalD between categories consists of:","category":"page"},{"location":"category_theory.html","page":"Category Theory","title":"Category Theory","text":"An object mapping F_textob textOb(mathcalC) to textOb(mathcalD)\nA morphism mapping F_textmor textHom_mathcalC(AB) to textHom_mathcalD(F(A)F(B))","category":"page"},{"location":"category_theory.html","page":"Category Theory","title":"Category Theory","text":"For theoretical foundations and applications of functors in MES, see MES23: Functorial Evolution.","category":"page"},{"location":"category_theory.html#Implementation-2","page":"Category Theory","title":"Implementation","text":"","category":"section"},{"location":"category_theory.html","page":"Category Theory","title":"Category Theory","text":"Functors are implemented in the Moma.Categories module as:","category":"page"},{"location":"category_theory.html","page":"Category Theory","title":"Category Theory","text":"Functor (lines 132-138)","category":"page"},{"location":"category_theory.html","page":"Category Theory","title":"Category Theory","text":"# Implementation in Categories.jl\nstruct Functor\n    source::Category\n    target::Category\n    object_map::Dict{Object,Object}\n    morphism_map::Dict{Morphism,Morphism}\n    name::Symbol\nend","category":"page"},{"location":"category_theory.html#Examples-2","page":"Category Theory","title":"Examples","text":"","category":"section"},{"location":"category_theory.html","page":"Category Theory","title":"Category Theory","text":"The following examples demonstrate functor creation and verification:","category":"page"},{"location":"category_theory.html","page":"Category Theory","title":"Category Theory","text":"using Moma.Categories\n\n# Examples from Categories.jl docstrings\nsrc_cat = Category([A, B], [f], :source)\ntgt_cat = Category([C], [identity(C)], :target)\n\n# Define functor mappings\nobj_map = Dict(A => C, B => C)\nmorph_map = Dict(f => identity(C))\n\n# Create functor\nF = Functor(src_cat, tgt_cat, obj_map, morph_map, :F)","category":"page"},{"location":"category_theory.html#Natural-Transformations","page":"Category Theory","title":"Natural Transformations","text":"","category":"section"},{"location":"category_theory.html#Mathematical-Definition-3","page":"Category Theory","title":"Mathematical Definition","text":"","category":"section"},{"location":"category_theory.html","page":"Category Theory","title":"Category Theory","text":"Given functors FG mathcalC to mathcalD, a natural transformation eta F Rightarrow G consists of:","category":"page"},{"location":"category_theory.html","page":"Category Theory","title":"Category Theory","text":"A family of morphisms eta_A F(A) to G(A) forall A in textOb(mathcalC)","category":"page"},{"location":"category_theory.html","page":"Category Theory","title":"Category Theory","text":"For the role of natural transformations in MES, see MES07: Natural Transformations and System Evolution.","category":"page"},{"location":"category_theory.html","page":"Category Theory","title":"Category Theory","text":"Such that the naturality condition holds:","category":"page"},{"location":"category_theory.html","page":"Category Theory","title":"Category Theory","text":"G(f) circ eta_A = eta_B circ F(f) forall f A to B in mathcalC","category":"page"},{"location":"category_theory.html","page":"Category Theory","title":"Category Theory","text":"beginCD\nF(A) F(f) F(B) \nVeta_AVV Veta_BVV \nG(A) G(f) G(B)\nendCD","category":"page"},{"location":"category_theory.html#Implementation-3","page":"Category Theory","title":"Implementation","text":"","category":"section"},{"location":"category_theory.html","page":"Category Theory","title":"Category Theory","text":"Natural transformations are implemented in the Moma.Categories module as:","category":"page"},{"location":"category_theory.html","page":"Category Theory","title":"Category Theory","text":"NaturalTransformation (lines 151-156)","category":"page"},{"location":"category_theory.html","page":"Category Theory","title":"Category Theory","text":"# Implementation in Categories.jl\nstruct NaturalTransformation\n    source::Functor\n    target::Functor\n    components::Dict{Object,Morphism}\n    name::Symbol\nend","category":"page"},{"location":"category_theory.html#Examples-3","page":"Category Theory","title":"Examples","text":"","category":"section"},{"location":"category_theory.html","page":"Category Theory","title":"Category Theory","text":"The following examples demonstrate natural transformation creation and verification:","category":"page"},{"location":"category_theory.html","page":"Category Theory","title":"Category Theory","text":"using Moma.Categories\n\n# Examples from Categories.jl docstrings\ncomponents = Dict(\n    A => Morphism(F.object_map[A], G.object_map[A], x -> x, :eta_A),\n    B => Morphism(F.object_map[B], G.object_map[B], x -> x, :eta_B)\n)\n\neta = NaturalTransformation(F, G, components, :eta)","category":"page"},{"location":"category_theory.html#Patterns-and-Colimits","page":"Category Theory","title":"Patterns and Colimits","text":"","category":"section"},{"location":"category_theory.html#Mathematical-Definition-4","page":"Category Theory","title":"Mathematical Definition","text":"","category":"section"},{"location":"category_theory.html","page":"Category Theory","title":"Category Theory","text":"A pattern P in a category mathcalC consists of:","category":"page"},{"location":"category_theory.html","page":"Category Theory","title":"Category Theory","text":"A diagram D mathcalJ to mathcalC where mathcalJ is a small category\nObjects D(j) for each j in textOb(mathcalJ)\nMorphisms D(f) D(j) to D(k) for each f j to k in mathcalJ","category":"page"},{"location":"category_theory.html","page":"Category Theory","title":"Category Theory","text":"For the significance of patterns and colimits in complex systems, see MES23: Patterns and Complexity.","category":"page"},{"location":"category_theory.html","page":"Category Theory","title":"Category Theory","text":"A colimit of pattern P consists of:","category":"page"},{"location":"category_theory.html","page":"Category Theory","title":"Category Theory","text":"An object textcolim(P)\nA family of morphisms iota_j D(j) to textcolim(P)","category":"page"},{"location":"category_theory.html","page":"Category Theory","title":"Category Theory","text":"Such that:","category":"page"},{"location":"category_theory.html","page":"Category Theory","title":"Category Theory","text":"iota_k circ D(f) = iota_j for all f j to k in mathcalJ\nUniversal property: For any other cocone (C (gamma_j)_j in mathcalJ), there exists a unique u textcolim(P) to C such that u circ iota_j = gamma_j","category":"page"},{"location":"category_theory.html","page":"Category Theory","title":"Category Theory","text":"beginCD\nD(j) D(f) D(k) \nViota_jVV VViota_kV \ntextcolim(P) = textcolim(P)\nendCD","category":"page"},{"location":"category_theory.html#Implementation-4","page":"Category Theory","title":"Implementation","text":"","category":"section"},{"location":"category_theory.html","page":"Category Theory","title":"Category Theory","text":"Patterns and colimits are implemented in the Moma.Categories module as:","category":"page"},{"location":"category_theory.html","page":"Category Theory","title":"Category Theory","text":"Pattern (lines 169-174)\ncreate_pattern (lines 271-284)\ncheck_binding (lines 318-342)\nfind_colimit (lines 384-401)","category":"page"},{"location":"category_theory.html","page":"Category Theory","title":"Category Theory","text":"# Implementation in Categories.jl\nstruct Pattern\n    category::Category\n    objects::Vector{Object}\n    morphisms::Vector{Morphism}\n    name::Symbol\nend\n\nstruct Colimit\n    pattern::Pattern\n    colimit_object::Object\n    injections::Dict{Object,Morphism}\nend","category":"page"},{"location":"category_theory.html#Examples-4","page":"Category Theory","title":"Examples","text":"","category":"section"},{"location":"category_theory.html","page":"Category Theory","title":"Category Theory","text":"The following examples demonstrate pattern and colimit creation:","category":"page"},{"location":"category_theory.html","page":"Category Theory","title":"Category Theory","text":"using Moma.Categories\n\n# Examples from Categories.jl docstrings\npattern = create_pattern(cat, [A, B], [f])\ncolimit_obj, bindings = find_colimit(pattern)\n@assert check_binding(colimit_obj, bindings, pattern)","category":"page"},{"location":"category_theory.html#Memory-Evolutive-Systems","page":"Category Theory","title":"Memory Evolutive Systems","text":"","category":"section"},{"location":"category_theory.html#Mathematical-Definition-5","page":"Category Theory","title":"Mathematical Definition","text":"","category":"section"},{"location":"category_theory.html","page":"Category Theory","title":"Category Theory","text":"A Memory Evolutive System (MES) consists of:","category":"page"},{"location":"category_theory.html","page":"Category Theory","title":"Category Theory","text":"A category mathcalC of components and their relationships\nA hierarchy of complexity levels through colimit formation\nA dynamic structure through time evolution","category":"page"},{"location":"category_theory.html","page":"Category Theory","title":"Category Theory","text":"For a comprehensive introduction to MES, see MES07: Introduction and MES23: Memory Evolutive Systems.","category":"page"},{"location":"category_theory.html","page":"Category Theory","title":"Category Theory","text":"The key operations include:","category":"page"},{"location":"category_theory.html","page":"Category Theory","title":"Category Theory","text":"Pattern formation through selection of objects and morphisms\nColimit computation for complex component formation\nTemporal evolution through functorial transitions","category":"page"},{"location":"category_theory.html#Implementation-5","page":"Category Theory","title":"Implementation","text":"","category":"section"},{"location":"category_theory.html","page":"Category Theory","title":"Category Theory","text":"The MES implementation builds upon the previous structures:","category":"page"},{"location":"category_theory.html","page":"Category Theory","title":"Category Theory","text":"Uses categories to represent system state\nEmploys patterns to identify meaningful subsystems\nComputes colimits to form higher-order components\nTracks temporal evolution through category morphisms","category":"page"},{"location":"category_theory.html","page":"Category Theory","title":"Category Theory","text":"For example, creating a basic hierarchical structure:","category":"page"},{"location":"category_theory.html","page":"Category Theory","title":"Category Theory","text":"# Create base level components\nA = Object(:A, \"base_component_1\")\nB = Object(:B, \"base_component_2\")\nf = Morphism(A, B, x -> process(x), :f)\n\n# Form a pattern\npattern = Pattern(category, [A, B], [f])\n\n# Compute colimit for higher-order component\ncolimit = find_colimit(pattern)","category":"page"},{"location":"category_theory.html#Examples-5","page":"Category Theory","title":"Examples","text":"","category":"section"},{"location":"category_theory.html","page":"Category Theory","title":"Category Theory","text":"# Create base level components\nneuron1 = Object(:N1, \"neuron_data_1\")\nneuron2 = Object(:N2, \"neuron_data_2\")\nsynapse = Morphism(neuron1, neuron2, \n                  x -> \"synapse_\" * x, :syn)\n\n# Create neural pattern\nneural_cat = Category([neuron1, neuron2], [synapse], :neural)\npattern = create_pattern(neural_cat, [neuron1, neuron2], [synapse])\n\n# Form higher-order component (neural assembly)\nassembly, bindings = find_colimit(pattern)\n\n# Verify the formation\n@assert check_binding(assembly, bindings, pattern)","category":"page"},{"location":"category_theory.html#Advanced-Examples","page":"Category Theory","title":"Advanced Examples","text":"","category":"section"},{"location":"category_theory.html#Custom-Data-Types","page":"Category Theory","title":"Custom Data Types","text":"","category":"section"},{"location":"category_theory.html","page":"Category Theory","title":"Category Theory","text":"The category theory framework can be used with any custom data types. Here's an example using geometric objects:","category":"page"},{"location":"category_theory.html","page":"Category Theory","title":"Category Theory","text":"using Moma.Categories\n\n# Define custom data types\nstruct Point\n    x::Float64\n    y::Float64\nend\n\nstruct Line\n    start::Point\n    ends::Point\nend\n\n# Create objects with custom data\np1 = Object(:P1, Point(0.0, 0.0))\np2 = Object(:P2, Point(1.0, 1.0))\nl1 = Object(:L1, Line(Point(0.0, 0.0), Point(1.0, 1.0)))\n\n# Create morphisms between custom objects\nf = Morphism(p1, l1, p -> Line(p, Point(p.x + 1.0, p.y + 1.0)), :f)\n\n# Create a category of geometric objects\ngeom_cat = Category([p1, p2, l1], [f], :Geometry)\n\n# Create and verify patterns\ngeom_pattern = create_pattern(geom_cat, [p1, l1], [f])","category":"page"},{"location":"category_theory.html#Error-Handling","page":"Category Theory","title":"Error Handling","text":"","category":"section"},{"location":"category_theory.html","page":"Category Theory","title":"Category Theory","text":"The framework includes comprehensive error checking to ensure categorical laws are maintained:","category":"page"},{"location":"category_theory.html","page":"Category Theory","title":"Category Theory","text":"using Moma.Categories\n\n# Attempting to compose incompatible morphisms\nf = Morphism(A, B, x -> x, :f)\ng = Morphism(C, A, x -> x, :g)\ntry\n    compose(f, g)  # This will throw an error\ncatch e\n    println(\"Error: \", e)  # \"Morphisms are not composable\"\nend\n\n# Attempting to create invalid patterns\ntry\n    create_pattern(cat, [Object(:X, 0)], [])  # Object not in category\ncatch e\n    println(\"Error: \", e)  # \"Objects must belong to the category\"\nend\n\n# Attempting to find invalid colimits\ninvalid_pattern = create_pattern(cat, [A, B], [])\ncolimit_obj, bindings = find_colimit(invalid_pattern)\ntry\n    check_binding(Object(:bad, 0), Dict(), invalid_pattern)\ncatch e\n    println(\"Error: \", e)  # Missing bindings\nend","category":"page"},{"location":"category_theory.html#Further-Reading","page":"Category Theory","title":"Further Reading","text":"","category":"section"},{"location":"category_theory.html","page":"Category Theory","title":"Category Theory","text":"For more detailed mathematical background and applications:","category":"page"},{"location":"category_theory.html","page":"Category Theory","title":"Category Theory","text":"MES23: Newer developments in Memory Evolutive Systems on human-machine interaction\nMES07: Memory Evolutive Systems (MES)\nMoMa25 Monetary Macro Accounting (MoMa) Theory (MoMaT)\nPapers: Complete list of related publications and theoretical background","category":"page"},{"location":"mes23.html#MES25:-A-Mathematical-Framework-for-Enriching-Human-Machine-Interactions","page":"MES25: A Mathematical Framework for Enriching Human-Machine Interactions","title":"MES25: A Mathematical Framework for Enriching Human-Machine Interactions","text":"","category":"section"},{"location":"mes23.html#Overview","page":"MES25: A Mathematical Framework for Enriching Human-Machine Interactions","title":"Overview","text":"","category":"section"},{"location":"mes23.html","page":"MES25: A Mathematical Framework for Enriching Human-Machine Interactions","title":"MES25: A Mathematical Framework for Enriching Human-Machine Interactions","text":"This paper presents a conceptual mathematical framework for developing rich human-machine interactions to improve decision-making in social organizations. It introduces the concept of a \"multi-level artificial cognitive system\" called a data analyser (DA) that collaborates with humans in data analysis and decision-making processes.","category":"page"},{"location":"mes23.html#Key-Concepts","page":"MES25: A Mathematical Framework for Enriching Human-Machine Interactions","title":"Key Concepts","text":"","category":"section"},{"location":"mes23.html#Data-Analyser-(DA)","page":"MES25: A Mathematical Framework for Enriching Human-Machine Interactions","title":"Data Analyser (DA)","text":"","category":"section"},{"location":"mes23.html","page":"MES25: A Mathematical Framework for Enriching Human-Machine Interactions","title":"MES25: A Mathematical Framework for Enriching Human-Machine Interactions","text":"The DA is designed to:","category":"page"},{"location":"mes23.html","page":"MES25: A Mathematical Framework for Enriching Human-Machine Interactions","title":"MES25: A Mathematical Framework for Enriching Human-Machine Interactions","text":"Collect and analyze data\nLearn and develop autonomous procedures\nAnticipate situations\nDevelop new responses\nImprove decision-making processes","category":"page"},{"location":"mes23.html#Human-Machine-Partnership","page":"MES25: A Mathematical Framework for Enriching Human-Machine Interactions","title":"Human-Machine Partnership","text":"","category":"section"},{"location":"mes23.html","page":"MES25: A Mathematical Framework for Enriching Human-Machine Interactions","title":"MES25: A Mathematical Framework for Enriching Human-Machine Interactions","text":"The framework focuses on:","category":"page"},{"location":"mes23.html","page":"MES25: A Mathematical Framework for Enriching Human-Machine Interactions","title":"MES25: A Mathematical Framework for Enriching Human-Machine Interactions","text":"Collaborative data analysis\nKnowledge extension\nAutonomous learning\nCreation of new procedures\nDeep anticipation capabilities","category":"page"},{"location":"mes23.html#Memory-Evolutive-Systems-Integration","page":"MES25: A Mathematical Framework for Enriching Human-Machine Interactions","title":"Memory Evolutive Systems Integration","text":"","category":"section"},{"location":"mes23.html","page":"MES25: A Mathematical Framework for Enriching Human-Machine Interactions","title":"MES25: A Mathematical Framework for Enriching Human-Machine Interactions","text":"The paper uses MES to describe:","category":"page"},{"location":"mes23.html","page":"MES25: A Mathematical Framework for Enriching Human-Machine Interactions","title":"MES25: A Mathematical Framework for Enriching Human-Machine Interactions","text":"Social organization operations\nDA construction and evolution\nMulti-scale system interactions\nMulti-agent coordination\nMulti-temporality handling","category":"page"},{"location":"mes23.html#Technical-Framework","page":"MES25: A Mathematical Framework for Enriching Human-Machine Interactions","title":"Technical Framework","text":"","category":"section"},{"location":"mes23.html#AI-Integration","page":"MES25: A Mathematical Framework for Enriching Human-Machine Interactions","title":"AI Integration","text":"","category":"section"},{"location":"mes23.html","page":"MES25: A Mathematical Framework for Enriching Human-Machine Interactions","title":"MES25: A Mathematical Framework for Enriching Human-Machine Interactions","text":"The paper discusses:","category":"page"},{"location":"mes23.html","page":"MES25: A Mathematical Framework for Enriching Human-Machine Interactions","title":"MES25: A Mathematical Framework for Enriching Human-Machine Interactions","text":"Historical AI development\nSymbolic AI approaches\nConnectionist paradigms\nIntegration of multiple AI paradigms\nCategory theory applications","category":"page"},{"location":"mes23.html#Implementation-Aspects","page":"MES25: A Mathematical Framework for Enriching Human-Machine Interactions","title":"Implementation Aspects","text":"","category":"section"},{"location":"mes23.html","page":"MES25: A Mathematical Framework for Enriching Human-Machine Interactions","title":"MES25: A Mathematical Framework for Enriching Human-Machine Interactions","text":"Key implementation features:","category":"page"},{"location":"mes23.html","page":"MES25: A Mathematical Framework for Enriching Human-Machine Interactions","title":"MES25: A Mathematical Framework for Enriching Human-Machine Interactions","text":"Multi-level cognitive systems\nRich human-machine interactions\nAnticipatory capabilities\nRisk prevention strategies\nOpportunity identification","category":"page"},{"location":"mes23.html#Applications","page":"MES25: A Mathematical Framework for Enriching Human-Machine Interactions","title":"Applications","text":"","category":"section"},{"location":"mes23.html#Healthcare-Example","page":"MES25: A Mathematical Framework for Enriching Human-Machine Interactions","title":"Healthcare Example","text":"","category":"section"},{"location":"mes23.html","page":"MES25: A Mathematical Framework for Enriching Human-Machine Interactions","title":"MES25: A Mathematical Framework for Enriching Human-Machine Interactions","text":"Demonstrates DA implementation in:","category":"page"},{"location":"mes23.html","page":"MES25: A Mathematical Framework for Enriching Human-Machine Interactions","title":"MES25: A Mathematical Framework for Enriching Human-Machine Interactions","text":"Symptom detection\nAutonomous response selection\nDecision-making participation\nCommunication improvement\nMisunderstanding detection","category":"page"},{"location":"mes23.html#General-Applications","page":"MES25: A Mathematical Framework for Enriching Human-Machine Interactions","title":"General Applications","text":"","category":"section"},{"location":"mes23.html","page":"MES25: A Mathematical Framework for Enriching Human-Machine Interactions","title":"MES25: A Mathematical Framework for Enriching Human-Machine Interactions","text":"The framework can be applied to:","category":"page"},{"location":"mes23.html","page":"MES25: A Mathematical Framework for Enriching Human-Machine Interactions","title":"MES25: A Mathematical Framework for Enriching Human-Machine Interactions","text":"Social organizations\nHealthcare institutions\nEducational systems\nBusiness environments\nComplex decision-making scenarios","category":"page"},{"location":"mes23.html#Future-Directions","page":"MES25: A Mathematical Framework for Enriching Human-Machine Interactions","title":"Future Directions","text":"","category":"section"},{"location":"mes23.html","page":"MES25: A Mathematical Framework for Enriching Human-Machine Interactions","title":"MES25: A Mathematical Framework for Enriching Human-Machine Interactions","text":"The paper suggests development paths for:","category":"page"},{"location":"mes23.html","page":"MES25: A Mathematical Framework for Enriching Human-Machine Interactions","title":"MES25: A Mathematical Framework for Enriching Human-Machine Interactions","text":"Third-generation AI systems\nEnhanced human-machine collaboration\nImproved anticipatory capabilities\nRisk prevention mechanisms\nDecision-making optimization ","category":"page"},{"location":"index.html#MoMa:-Central-Banks-for-All","page":"Home","title":"MoMa: Central Banks for All","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"A Julia package implementing a Monetary Macro Accounting (MoMa) of Menéndez and Winschel. To be extended with categorical tools of Memory Evolutive Systems (MES) of Ehresmann and Vanbremeersch.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"The monetary theory of MoMa works for national accounting, sectors and companies but also for within companies as holdings with subsidiaries and down to smaller levels down like to processes of a box ordering screws. MoMa is a multi-level accounting theory for macro accounting with different time scales extending micro accounting aka double-entry bookkeeping.","category":"page"},{"location":"index.html#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"This documentation contain implementations and","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Basic category theoretical constructions\nBasic simulation of a MoMa national accounting\nSummaries and pdfs of MES and MoMa","category":"page"},{"location":"index.html#Documentation-Sections","page":"Home","title":"Documentation Sections","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Category Theory - Mathematical foundations and implementation examples\nPapers - Mathematical foundations and theoretical background\nAPI Reference - Documentation of all functions and types ","category":"page"},{"location":"moma25.html#MoMa25:-Monetary-Macro-Accounting-Theory","page":"MoMa25: Monetary Macro Accounting Theory","title":"MoMa25: Monetary Macro Accounting Theory","text":"","category":"section"},{"location":"moma25.html#Overview","page":"MoMa25: Monetary Macro Accounting Theory","title":"Overview","text":"","category":"section"},{"location":"moma25.html","page":"MoMa25: Monetary Macro Accounting Theory","title":"MoMa25: Monetary Macro Accounting Theory","text":"This paper develops a specification for software for macro accounting (MoMa) and a monetary macro accounting theory (MoMaT). It presents a novel approach where money functions as a medium of payment for obligations and debts, rather than just a medium of exchange.","category":"page"},{"location":"moma25.html#Key-Concepts","page":"MoMa25: Monetary Macro Accounting Theory","title":"Key Concepts","text":"","category":"section"},{"location":"moma25.html#Theoretical-Framework","page":"MoMa25: Monetary Macro Accounting Theory","title":"Theoretical Framework","text":"","category":"section"},{"location":"moma25.html","page":"MoMa25: Monetary Macro Accounting Theory","title":"MoMa25: Monetary Macro Accounting Theory","text":"The paper addresses:","category":"page"},{"location":"moma25.html","page":"MoMa25: Monetary Macro Accounting Theory","title":"MoMa25: Monetary Macro Accounting Theory","text":"Temporal misalignment in production\nLegal principles of Separation and Abstraction\nDebt, contracts, and property rights\nMulti-level monetary systems analysis","category":"page"},{"location":"moma25.html#System-Levels","page":"MoMa25: Monetary Macro Accounting Theory","title":"System Levels","text":"","category":"section"},{"location":"moma25.html","page":"MoMa25: Monetary Macro Accounting Theory","title":"MoMa25: Monetary Macro Accounting Theory","text":"The monetary system operates at three interconnected levels:","category":"page"},{"location":"moma25.html","page":"MoMa25: Monetary Macro Accounting Theory","title":"MoMa25: Monetary Macro Accounting Theory","text":"Micro Level: Division of labor facilitation\nMeso Level: Risk sharing in banking\nMacro Level: GDP distribution through issued money","category":"page"},{"location":"moma25.html#Core-Components","page":"MoMa25: Monetary Macro Accounting Theory","title":"Core Components","text":"","category":"section"},{"location":"moma25.html#Bill-of-Exchange-(BoE)","page":"MoMa25: Monetary Macro Accounting Theory","title":"Bill of Exchange (BoE)","text":"","category":"section"},{"location":"moma25.html","page":"MoMa25: Monetary Macro Accounting Theory","title":"MoMa25: Monetary Macro Accounting Theory","text":"Serves as:","category":"page"},{"location":"moma25.html","page":"MoMa25: Monetary Macro Accounting Theory","title":"MoMa25: Monetary Macro Accounting Theory","text":"Unifying instrument\nBridge between debt processes\nMoney issuing mechanism\nConnection between fiat and gold-based systems","category":"page"},{"location":"moma25.html#Mathematical-Foundations","page":"MoMa25: Monetary Macro Accounting Theory","title":"Mathematical Foundations","text":"","category":"section"},{"location":"moma25.html","page":"MoMa25: Monetary Macro Accounting Theory","title":"MoMa25: Monetary Macro Accounting Theory","text":"Utilizes:","category":"page"},{"location":"moma25.html","page":"MoMa25: Monetary Macro Accounting Theory","title":"MoMa25: Monetary Macro Accounting Theory","text":"Sheaf theory for accounting invariances\nHomology theory for monetary policy\nOpen Games for computation\nMulti-agent model analysis","category":"page"},{"location":"moma25.html#Applications","page":"MoMa25: Monetary Macro Accounting Theory","title":"Applications","text":"","category":"section"},{"location":"moma25.html#Supply-Chain-Finance","page":"MoMa25: Monetary Macro Accounting Theory","title":"Supply Chain Finance","text":"","category":"section"},{"location":"moma25.html","page":"MoMa25: Monetary Macro Accounting Theory","title":"MoMa25: Monetary Macro Accounting Theory","text":"Debt networks analysis\nPayment systems integration\nRisk distribution mechanisms\nFinancial obligation tracking","category":"page"},{"location":"moma25.html#Monetary-Policy","page":"MoMa25: Monetary Macro Accounting Theory","title":"Monetary Policy","text":"","category":"section"},{"location":"moma25.html","page":"MoMa25: Monetary Macro Accounting Theory","title":"MoMa25: Monetary Macro Accounting Theory","text":"Central banking operations\nMoney circulation analysis\nDebt vortices study\nFinancial obligation resolution","category":"page"},{"location":"moma25.html#Technical-Implementation","page":"MoMa25: Monetary Macro Accounting Theory","title":"Technical Implementation","text":"","category":"section"},{"location":"moma25.html#Software-Components","page":"MoMa25: Monetary Macro Accounting Theory","title":"Software Components","text":"","category":"section"},{"location":"moma25.html","page":"MoMa25: Monetary Macro Accounting Theory","title":"MoMa25: Monetary Macro Accounting Theory","text":"MoMa implementation can include:","category":"page"},{"location":"moma25.html","page":"MoMa25: Monetary Macro Accounting Theory","title":"MoMa25: Monetary Macro Accounting Theory","text":"Macro accounting systems\nSmart contracts\nStructural econometric models\nData analysis tools","category":"page"},{"location":"moma25.html#Mathematical-Tools","page":"MoMa25: Monetary Macro Accounting Theory","title":"Mathematical Tools","text":"","category":"section"},{"location":"moma25.html","page":"MoMa25: Monetary Macro Accounting Theory","title":"MoMa25: Monetary Macro Accounting Theory","text":"Proposes:","category":"page"},{"location":"moma25.html","page":"MoMa25: Monetary Macro Accounting Theory","title":"MoMa25: Monetary Macro Accounting Theory","text":"Category theory\nSheaf theory like MES colimits\nHomology theory like MES coregulators\nGame theory","category":"page"},{"location":"moma25.html#Future-Implications","page":"MoMa25: Monetary Macro Accounting Theory","title":"Future Implications","text":"","category":"section"},{"location":"moma25.html","page":"MoMa25: Monetary Macro Accounting Theory","title":"MoMa25: Monetary Macro Accounting Theory","text":"The framework provides foundations for:","category":"page"},{"location":"moma25.html","page":"MoMa25: Monetary Macro Accounting Theory","title":"MoMa25: Monetary Macro Accounting Theory","text":"Macro economic research in monetary systems\nDigital currency development, like stable coins\nReal estate management \nRenewable energy management systems, virtual power plants\nEconomic policy making ","category":"page"},{"location":"papers.html#Papers","page":"Papers","title":"Papers","text":"","category":"section"},{"location":"papers.html","page":"Papers","title":"Papers","text":"This section provides an overview of the papers that form the theoretical foundation of the MoMa package.","category":"page"},{"location":"papers.html#MoMa25:-Monetary-Macro-Accounting","page":"Papers","title":"MoMa25: Monetary Macro Accounting","text":"","category":"section"},{"location":"papers.html","page":"Papers","title":"Papers","text":"Summary, pdf","category":"page"},{"location":"papers.html","page":"Papers","title":"Papers","text":"MoMa25 develops a specification for software for macro accounting (MoMa) and a monetary macro accounting theory (MoMaT). The paper presents a novel approach where money functions as a medium of payment for obligations and debts, rather than just a medium of exchange. It addresses temporal misalignment in production, legal principles of Separation and Abstraction, and debt management through a three-level system: micro (division of labor), meso (banking risk sharing), and macro (GDP distribution). The paper proposes and argues why to use mathematical tools including sheaf theory for accounting invariances, homology theory for monetary policy, and open games for computation, with applications in supply chain finance, monetary policy, renewable energy models, or digital currency development.","category":"page"},{"location":"papers.html","page":"Papers","title":"Papers","text":"A MoMa Simulation in Julia of a National Accounting is in src/original_moma directory contains several files used for generating and checking simulation data underlying the MoMa paper. momascf_v02_en.jl is a simulation of the following basic MoMa macro accounting structure.","category":"page"},{"location":"papers.html","page":"Papers","title":"Papers","text":"(Image: Basic National Accounting Structure) ","category":"page"},{"location":"papers.html#MES23:-Human–Machine-Interactions","page":"Papers","title":"MES23: Human–Machine Interactions","text":"","category":"section"},{"location":"papers.html","page":"Papers","title":"Papers","text":"Summary, pdf","category":"page"},{"location":"papers.html","page":"Papers","title":"Papers","text":"MES23 applies the Memory Evolutive Systems framework to analyze human-machine interactions in complex systems. The paper explores how multiple agents with different temporalities can cooperate effectively, focusing on the synchronization and coordination challenges that arise in human-machine systems. It provides insights into designing more effective collaborative systems where humans and machines work together, taking into account their different processing speeds and decision-making capabilities.","category":"page"},{"location":"papers.html#MES07:-Memory-Evolutive-Systems","page":"Papers","title":"MES07: Memory Evolutive Systems","text":"","category":"section"},{"location":"papers.html","page":"Papers","title":"Papers","text":"Summary, pdf","category":"page"},{"location":"papers.html","page":"Papers","title":"Papers","text":"MES07 presents a comprehensive mathematical framework for modeling complex evolutionary systems using category theory. The paper introduces Memory Evolutive Systems (MES) as a theoretical foundation for understanding how biological, cognitive, and social systems develop and adapt over time. It explains how multiple hierarchical components interact and evolve, incorporating concepts such as emergence, complexity, and time-scaling. The framework is particularly valuable for modeling systems with multiple interconnected levels of organization, memory formation, and adaptive behavior.","category":"page"},{"location":"papers.html","page":"Papers","title":"Papers","text":"A comprehensive synthesis of two decades of research on memory evolutive systems, presenting mathematical models for autonomous evolutionary systems such as biological, social, and nervous systems.","category":"page"}]
}
