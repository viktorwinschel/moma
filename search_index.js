var documenterSearchIndex = {"docs":
[{"location":"error_handling/#Error-Handling","page":"Error Handling","title":"Error Handling","text":"","category":"section"},{"location":"error_handling/","page":"Error Handling","title":"Error Handling","text":"The framework includes comprehensive error checking to ensure categorical laws are maintained:","category":"page"},{"location":"error_handling/","page":"Error Handling","title":"Error Handling","text":"using Moma\n\n# Declare global variables\nglobal incompatible_caught = false\nglobal invalid_pattern_caught = false\nglobal invalid_binding_caught = false\n\n# Create some basic objects and morphisms for testing\nA = Object(:A, 1)\nB = Object(:B, 2)\nC = Object(:C, 3)\nvalid_f = Morphism(A, B, x -> x + 1, :valid_f)\nvalid_g = Morphism(B, C, x -> x * 2, :valid_g)\ncat = Category([A, B, C], [valid_f, valid_g], :TestCat)\n\n# Test object properties\n@assert A.id == :A && A.data == 1\n@assert B.id == :B && B.data == 2\n@assert C.id == :C && C.data == 3\n\n# Test morphism properties\n@assert valid_f.source == A && valid_f.target == B\n@assert valid_g.source == B && valid_g.target == C\n@assert valid_f.id == :valid_f && valid_g.id == :valid_g\n@assert valid_f.map(1) == 2  # Test function mapping\n@assert valid_g.map(2) == 4  # Test function mapping\n\n# Test category properties\n@assert cat.id == :TestCat\n@assert length(cat.objects) == 3\n@assert length(cat.morphisms) == 2\n@assert A in cat.objects && B in cat.objects && C in cat.objects\n@assert valid_f in cat.morphisms && valid_g in cat.morphisms\n\n# Test valid composition works\ncomposed = compose(valid_f, valid_g)\n@assert composed.source == A\n@assert composed.target == C\n@assert composed.map(1) == 4  # (1 + 1) * 2\n@assert composed.id == :valid_f_valid_g\n\n# Test identity morphism\nid_A = identity_morphism(A)\n@assert id_A.id == A.id  # Identity morphism name\n\n# Test incompatible morphism composition\nf = Morphism(A, B, x -> x, :f)\ng = Morphism(C, A, x -> x, :g)\ntry\n    compose(f, g)\ncatch e\n    global incompatible_caught = true\n    @assert e isa ErrorException\n    @assert e.msg == \"Morphisms are not composable\"\nend\n@assert incompatible_caught\n\n# Test invalid pattern creation\ntry\n    X = Object(:X, 0)  # Object not in category\n    create_pattern(cat, [X], Morphism[])\ncatch e\n    global invalid_pattern_caught = true\n    @assert e isa ErrorException\n    @assert occursin(\"Objects must belong to the category\", e.msg)\nend\n@assert invalid_pattern_caught\n\n# Test valid pattern creation\nvalid_pattern = create_pattern(cat, [A, B], [valid_f])\n@assert valid_pattern.category == cat\n@assert length(valid_pattern.objects) == 2\n@assert length(valid_pattern.morphisms) == 1\n@assert A in valid_pattern.objects && B in valid_pattern.objects\n@assert valid_f in valid_pattern.morphisms\n@assert valid_pattern.id == Symbol(\"pattern_TestCat\")\n\n# Test invalid colimit binding\ntry\n    # Create a valid pattern first\n    bad_obj = Object(:bad, 0)\n    empty_bindings = Dict{Object{Int64},Morphism{Int64,Int64}}()\n    check_binding(bad_obj, empty_bindings, valid_pattern)\ncatch e\n    global invalid_binding_caught = true\n    @assert e isa ErrorException\n    @assert occursin(\"Missing bindings\", e.msg)\nend\n@assert invalid_binding_caught\n\n# Test morphism category membership\n@assert is_morphism_in_category(valid_f, cat)\n@assert is_morphism_in_category(valid_g, cat)\n@assert !is_morphism_in_category(Morphism(A, C, x -> x * 3, :h), cat)  # Non-member morphism","category":"page"},{"location":"error_handling/#Self-Healing-Systems-in-MES-and-Julia","page":"Error Handling","title":"Self-Healing Systems in MES and Julia","text":"","category":"section"},{"location":"error_handling/","page":"Error Handling","title":"Error Handling","text":"Memory Evolutive Systems (MES) introduce the concept of self-healing through their hierarchical organization and co-regulators. This concept can be implemented in Julia using its powerful error handling mechanisms. Here's how we can connect these ideas:","category":"page"},{"location":"error_handling/#MES-Self-Healing-Concepts","page":"Error Handling","title":"MES Self-Healing Concepts","text":"","category":"section"},{"location":"error_handling/","page":"Error Handling","title":"Error Handling","text":"Hierarchical Organization: MES systems are organized in levels, where each level can handle errors at its own scale\nCo-regulators: These are specialized subsystems that can detect and respond to errors\nMemory Links: Connections between different parts of the system that can be used for error recovery\nTime Scales: Different levels operate at different time scales, allowing for layered error handling","category":"page"},{"location":"error_handling/#Implementation-in-Julia","page":"Error Handling","title":"Implementation in Julia","text":"","category":"section"},{"location":"error_handling/","page":"Error Handling","title":"Error Handling","text":"We can (have not yet) implement these concepts using Julia's error handling mechanisms:","category":"page"},{"location":"error_handling/","page":"Error Handling","title":"Error Handling","text":"# Example of hierarchical error handling inspired by MES\nstruct SystemLevel\n    name::Symbol\n    co_regulators::Vector{Function}\n    memory_links::Dict{Symbol, Any}\n    time_scale::Float64\nend\n\n# Co-regulator function that can detect and handle errors\nfunction create_co_regulator(level::SystemLevel, error_type::Type)\n    return function handle_error(err::error_type)\n        # Log the error at this level\n        @info \"Error detected at level $(level.name)\" error=err\n        \n        # Try to recover using memory links\n        for (link_name, link_data) in level.memory_links\n            try\n                # Attempt recovery using stored information\n                recover_from_memory(err, link_data)\n                return true\n            catch e\n                @warn \"Recovery attempt failed for link $link_name\" error=e\n            end\n        end\n        \n        # If recovery fails, propagate to next level\n        rethrow(err)\n    end\nend\n\n# Example usage\nfunction setup_hierarchical_system()\n    # Create system levels with different time scales\n    low_level = SystemLevel(:low, [], Dict(), 0.1)  # Fast response\n    mid_level = SystemLevel(:mid, [], Dict(), 1.0)  # Medium response\n    high_level = SystemLevel(:high, [], Dict(), 10.0)  # Slow response\n    \n    # Add co-regulators for different error types\n    push!(low_level.co_regulators, create_co_regulator(low_level, ArgumentError))\n    push!(mid_level.co_regulators, create_co_regulator(mid_level, MethodError))\n    push!(high_level.co_regulators, create_co_regulator(high_level, ErrorException))\n    \n    return [low_level, mid_level, high_level]\nend\n\n# Example of using the hierarchical system\nfunction process_with_self_healing(data)\n    system = setup_hierarchical_system()\n    \n    try\n        # Attempt processing at lowest level\n        result = process_data(data)\n        return result\n    catch err\n        # Try each level's co-regulators\n        for level in system\n            for co_regulator in level.co_regulators\n                try\n                    return co_regulator(err)\n                catch e\n                    continue  # Try next co-regulator\n                end\n            end\n        end\n        # If all recovery attempts fail, propagate error\n        rethrow(err)\n    end\nend","category":"page"},{"location":"error_handling/#Key-Features-of-This-Implementation","page":"Error Handling","title":"Key Features of This Implementation","text":"","category":"section"},{"location":"error_handling/","page":"Error Handling","title":"Error Handling","text":"Layered Error Handling: Each system level can handle errors at its own time scale\nMemory-Based Recovery: Uses stored information (memory links) to attempt recovery\nCo-regulator Pattern: Specialized handlers for different types of errors\nGraceful Degradation: System can fall back to simpler modes when errors occur\nError Propagation: Errors can move up the hierarchy if they can't be handled at the current level","category":"page"},{"location":"error_handling/#Best-Practices","page":"Error Handling","title":"Best Practices","text":"","category":"section"},{"location":"error_handling/","page":"Error Handling","title":"Error Handling","text":"Define Clear Error Types: Create specific error types for different failure modes\nImplement Recovery Strategies: Each co-regulator should have specific recovery procedures\nMaintain State: Use memory links to store recovery-relevant information\nMonitor and Log: Track error patterns and recovery attempts\nTime-Aware Handling: Consider the time scale of each level when implementing recovery","category":"page"},{"location":"error_handling/","page":"Error Handling","title":"Error Handling","text":"This approach combines the theoretical framework of MES with Julia's practical error handling capabilities, creating robust, self-healing systems that can adapt to and recover from various types of failures.","category":"page"},{"location":"categories/#Category-Theory","page":"Categories","title":"Category Theory","text":"","category":"section"},{"location":"categories/","page":"Categories","title":"Categories","text":"This section provides a mathematical introduction to the category theory concepts implemented in MoMa.","category":"page"},{"location":"categories/#Category","page":"Categories","title":"Category","text":"","category":"section"},{"location":"categories/#Mathematical-Definition","page":"Categories","title":"Mathematical Definition","text":"","category":"section"},{"location":"categories/","page":"Categories","title":"Categories","text":"A category mathcalA consists of","category":"page"},{"location":"categories/","page":"Categories","title":"Categories","text":"A collection of objects textOb(mathcalA) with identity morphisms existstextid_A A to A, forall Ain mathcalA\nA collection of morphisms textHom(mathcalA), f_1 A_1 to A_2 with source A_1 and target A_2\nA composition operation circ textHom(A_2A_3) times textHom(A_1A_2) to textHom(A_1A_3) that satisfies\nAssociativity: (f_3circ f_2) circ f_1 = f_3 circ (f_2 circ f_1), forall f_1 A_1 to A_2 f_2 A_2 to A_3 f_3 A_3 to A_4\nIdentity: f circ textid_A_1 = f = textid_A_2 circ f, forall f A_1 to A_2","category":"page"},{"location":"categories/","page":"Categories","title":"Categories","text":"beginCD\nA_1 f_1 A_2 f_2 A_3 \nVtextid_A_1VV Vtextid_A_2VV Vtextid_A_3VV \nA_1 f_1 A_2 f_2 A_3\nendCD","category":"page"},{"location":"categories/#Implementation","page":"Categories","title":"Implementation","text":"","category":"section"},{"location":"categories/","page":"Categories","title":"Categories","text":"Category, Object, and Morphism are implemented in the Moma.Categories module.","category":"page"},{"location":"categories/","page":"Categories","title":"Categories","text":"struct Object{T}        # an object of type T consist of\n    id::Symbol          # name\n    data::T             # data of type T\nend\n\nstruct Morphism{S,T}    # a morphism of type (S,T) consist of\n    source::Object{S}   # source Object of type S\n    target::Object{T}   # target Object of type T\n    map::Function       # Julia function, i.e. computation\n    id::Symbol          # name\nend\n\nstruct Category                 # a category consist of\n    objects::Vector{Object}     # objects of type Vector of Objects\n    morphisms::Vector{Morphism} # morphisms of type Vector of Morphisms\n    id::Symbol                  # name\nend","category":"page"},{"location":"categories/","page":"Categories","title":"Categories","text":"For comprehensive tests of these implementations, see the test files in the repository.","category":"page"},{"location":"categories/#Examples","page":"Categories","title":"Examples","text":"","category":"section"},{"location":"categories/","page":"Categories","title":"Categories","text":"The following examples demonstrate the basic usage with the helper functions  identity_morphism, compose implemented in the Moma.Categories module.","category":"page"},{"location":"categories/","page":"Categories","title":"Categories","text":"using Moma\nusing Moma.Categories\nusing Test\n\n# Test Object creation\nobj1 = Object(:A, \"data1\")\n@assert obj1.id == :A && obj1.data == \"data1\"\nobj2 = Object(:B, \"data2\")\nobj3 = Object(:C, \"data3\")\n\n# Test Morphism creation and composition\nm1 = Morphism(obj1, obj2, x -> uppercase(x), :m1)\nm2 = Morphism(obj2, obj3, x -> x * \"!\", :m2)\n@assert m1.source == obj1 && m1.target == obj2 &&\n        m2.source == obj2 && m2.target == obj3 &&\n        m1.name == :m1 &&\n        m2.name == :m2 &&\n        m1.map(\"test\") == \"TEST\" &&\n        m2.map(\"test\") == \"test!\"\n\n# Test composition\nm3 = compose(m1, m2)\n@assert m3.source == obj1 &&\n        m3.target == obj3 &&\n        m3.map(\"test\") == \"TEST!\" &&\n        m3.name == :m1_m2 # name of composite symbolically composed by _\n@assert try \n        compose(m2, m1)\ncatch e\n        e.msg \nend  == \"Morphisms m2 and m1 are not composable, target of m2 C != A source of m1.\"\n\n# Test identity morphism\nid_morph = identity_morphism(obj1)\n@assert id_morph.source == obj1 &&\n        id_morph.target == obj1 &&\n        id_morph.map(\"test\") == \"test\" &&\n        id_morph.id == :id_A  #name of identity symbolically composed by _\n\n# Test Category creation and membership\ncat1 = Category([obj1, obj2], [m1, m2], :TestCat)\n@assert length(cat1.objects) == 2 &&\n        length(cat1.morphisms) == 2 &&\n        is_morphism_in_category(m1, cat1) &&\n        cat1.id == :TestCat &&\n        obj1 in cat1.objects &&\n        obj2 in cat1.objects &&\n        m1 in cat1.morphisms &&\n        m2 in cat1.morphisms","category":"page"},{"location":"categories/#Functors","page":"Categories","title":"Functors","text":"","category":"section"},{"location":"categories/#Mathematical-Definition-2","page":"Categories","title":"Mathematical Definition","text":"","category":"section"},{"location":"categories/","page":"Categories","title":"Categories","text":"A functor F mathcalA to mathcalB between categories consists of:","category":"page"},{"location":"categories/","page":"Categories","title":"Categories","text":"An object mapping F_textob textOb(mathcalA) to textOb(mathcalB)\nA morphism mapping F_textmor textHom_mathcalA(A_1A_2) to textHom_mathcalB(F(A_1)F(A_2))","category":"page"},{"location":"categories/","page":"Categories","title":"Categories","text":"Preservation of Identities: For each object A in mathcalA the commutative diagram","category":"page"},{"location":"categories/","page":"Categories","title":"Categories","text":"beginCD\nA textid_A A \nVFVV VFVV \nF(A) textid_F(A) F(A)\nendCD","category":"page"},{"location":"categories/","page":"Categories","title":"Categories","text":"says that the functor preserves identity F(textid_A)=textid_F(A), i.e. F maps identity mathrmid_A to mathrmid_F(A).","category":"page"},{"location":"categories/","page":"Categories","title":"Categories","text":"Preservation of Composition: For a composition A xrightarrowf B xrightarrowg the commutative diagram","category":"page"},{"location":"categories/","page":"Categories","title":"Categories","text":"beginCD\nA gcirc f C \nVFVV VFVV \nF(A) F(g)circ F(f) F(C)\nendCD","category":"page"},{"location":"categories/","page":"Categories","title":"Categories","text":"says that the functor F preserves composition F(gcirc f)=F(g)circ F(f).","category":"page"},{"location":"categories/#Implementation-2","page":"Categories","title":"Implementation","text":"","category":"section"},{"location":"categories/","page":"Categories","title":"Categories","text":"Functors are implemented in the Moma.Categories module as:","category":"page"},{"location":"categories/","page":"Categories","title":"Categories","text":"Functor","category":"page"},{"location":"categories/","page":"Categories","title":"Categories","text":"# Implementation in Categories.jl\nstruct Functor\n    source::Category\n    target::Category\n    object_map::Dict{Object,Object}\n    morphism_map::Dict{Morphism,Morphism}\n    name::Symbol\nend","category":"page"},{"location":"categories/#Examples-2","page":"Categories","title":"Examples","text":"","category":"section"},{"location":"categories/","page":"Categories","title":"Categories","text":"The following examples demonstrate functor creation and verification:","category":"page"},{"location":"categories/","page":"Categories","title":"Categories","text":"using Moma\n\n# Create source and target categories\nsrc_cat = Category([obj1, obj2], [m1], :source)\ntgt_cat = Category([obj3], [identity_morphism(obj3)], :target)\n\n# Define functor mappings\nobj_map = Dict(obj1 => obj3, obj2 => obj3)\nmorph_map = Dict(m1 => identity_morphism(obj3))\n\n# Create functor\nF = Functor(src_cat, tgt_cat, obj_map, morph_map, :F)","category":"page"},{"location":"categories/#Natural-Transformations","page":"Categories","title":"Natural Transformations","text":"","category":"section"},{"location":"categories/#Mathematical-Definition-3","page":"Categories","title":"Mathematical Definition","text":"","category":"section"},{"location":"categories/","page":"Categories","title":"Categories","text":"Given functors FG mathcalC to mathcalD, a natural transformation eta F Rightarrow G consists of:","category":"page"},{"location":"categories/","page":"Categories","title":"Categories","text":"A family of morphisms eta_A F(A) to G(A) forall A in textOb(mathcalC)","category":"page"},{"location":"categories/","page":"Categories","title":"Categories","text":"Such that the naturality condition holds:","category":"page"},{"location":"categories/","page":"Categories","title":"Categories","text":"G(f) circ eta_A = eta_B circ F(f) forall f A to B in mathcalC","category":"page"},{"location":"categories/","page":"Categories","title":"Categories","text":"beginCD\nF(A) F(f) F(B) \nVeta_AVV Veta_BVV \nG(A) G(f) G(B)\nendCD","category":"page"},{"location":"categories/#Implementation-3","page":"Categories","title":"Implementation","text":"","category":"section"},{"location":"categories/","page":"Categories","title":"Categories","text":"Natural transformations are implemented in the Moma.Categories module as:","category":"page"},{"location":"categories/","page":"Categories","title":"Categories","text":"NaturalTransformation","category":"page"},{"location":"categories/","page":"Categories","title":"Categories","text":"# Implementation in Categories.jl\nstruct NaturalTransformation\n    source::Functor\n    target::Functor\n    components::Dict{Object,Morphism}\n    name::Symbol\nend","category":"page"},{"location":"categories/#Examples-3","page":"Categories","title":"Examples","text":"","category":"section"},{"location":"categories/","page":"Categories","title":"Categories","text":"The following examples demonstrate natural transformation creation and verification:","category":"page"},{"location":"categories/","page":"Categories","title":"Categories","text":"using Moma\n\n# Create components for natural transformation\ncomponents = Dict(\n    obj1 => Morphism(F.object_map[obj1], G.object_map[obj1], x -> x, :eta_A),\n    obj2 => Morphism(F.object_map[obj2], G.object_map[obj2], x -> x, :eta_B)\n)\n\n# Create natural transformation\neta = NaturalTransformation(F, G, components, :eta)","category":"page"},{"location":"categories/#Patterns-and-Colimits","page":"Categories","title":"Patterns and Colimits","text":"","category":"section"},{"location":"categories/#Mathematical-Definition-4","page":"Categories","title":"Mathematical Definition","text":"","category":"section"},{"location":"categories/","page":"Categories","title":"Categories","text":"A pattern P in a category mathcalC consists of:","category":"page"},{"location":"categories/","page":"Categories","title":"Categories","text":"A diagram D mathcalJ to mathcalC where mathcalJ is a small category\nObjects D(j) for each j in textOb(mathcalJ)\nMorphisms D(f) D(j) to D(k) for each f j to k in mathcalJ","category":"page"},{"location":"categories/","page":"Categories","title":"Categories","text":"A colimit of pattern P consists of:","category":"page"},{"location":"categories/","page":"Categories","title":"Categories","text":"An object textcolim(P)\nA family of morphisms iota_j D(j) to textcolim(P)","category":"page"},{"location":"categories/","page":"Categories","title":"Categories","text":"Such that:","category":"page"},{"location":"categories/","page":"Categories","title":"Categories","text":"iota_k circ D(f) = iota_j for all f j to k in mathcalJ\nUniversal property: For any other cocone (C (gamma_j)_j in mathcalJ), there exists a unique u textcolim(P) to C such that u circ iota_j = gamma_j","category":"page"},{"location":"categories/","page":"Categories","title":"Categories","text":"beginCD\nD(j) D(f) D(k) \nViota_jVV VViota_kV \ntextcolim(P) = textcolim(P)\nendCD","category":"page"},{"location":"categories/#Implementation-4","page":"Categories","title":"Implementation","text":"","category":"section"},{"location":"categories/","page":"Categories","title":"Categories","text":"Patterns and colimits are implemented in the Moma.Categories module as:","category":"page"},{"location":"categories/","page":"Categories","title":"Categories","text":"Pattern","category":"page"},{"location":"categories/","page":"Categories","title":"Categories","text":"# Implementation in Categories.jl\nstruct Pattern\n    category::Category\n    objects::Vector{Object}\n    morphisms::Vector{Morphism}\n    name::Symbol\nend","category":"page"},{"location":"categories/","page":"Categories","title":"Categories","text":"The module provides functions for working with patterns and colimits:","category":"page"},{"location":"categories/","page":"Categories","title":"Categories","text":"create_pattern: Creates a pattern from objects and morphisms\ncheck_binding: Verifies if an object forms a colimit for a pattern\nfind_colimit: Computes the colimit of a pattern","category":"page"},{"location":"categories/#Examples-4","page":"Categories","title":"Examples","text":"","category":"section"},{"location":"categories/","page":"Categories","title":"Categories","text":"The following examples demonstrate pattern creation and colimit construction:","category":"page"},{"location":"categories/","page":"Categories","title":"Categories","text":"using Moma\nusing Moma.Categories\n\n# Create simple objects and morphisms\na = Object(:A, 1)\nb = Object(:B, 2)\nc = Object(:C, 3)\nf = Morphism(a, b, x -> x + 1, :f)\ng = Morphism(a, b, x -> x + 2, :g)\n@assert a.id == :A && a.data == 1 &&\n        b.id == :B && b.data == 2 &&\n        c.id == :C && c.data == 3 &&\n        f.name == :f &&\n        f.map(1) == 2\n\n# Create category and pattern\ncat = Category([a, b], [f], :ColimitTest)\npat = create_pattern(cat, [a, b], [f])\n@assert cat.name == :ColimitTest &&\n        length(cat.objects) == 2 && length(cat.morphisms) == 1 &&\n        length(pat.objects) == 2 && length(pat.morphisms) == 1 &&\n        a in pat.objects && b in pat.objects &&\n        f in pat.morphisms\n        try\n                create_pattern(cat, [a, c], [f])\n        catch e\n                e.msg\n        end == \"Object C must belong to the category ColimitTest\" &&\n        try\n                create_pattern(cat, [a, b], [g])\n        catch e\n                e.msg\n        end == \"Morphism g must belong to the category ColimitTest\"\n\n# Test binding checks\nbindings = Dict(\n        obj1 => Morphism(obj1, obj2, x -> uppercase(x), :bind1),\n        obj2 => identity_morphism(obj2)\n)\n@assert check_binding(obj2, bindings, pattern) &&\n        haskey(bindings, obj1) &&\n        haskey(bindings, obj2) &&\n        bindings[obj1].name == :bind1 &&\n        bindings[obj2].name == :id_B\n\n\n# Find colimit\ncolimit_obj, bindings = find_colimit(pat)\n\n# Test colimit properties\n@assert colimit_obj.data == [1, 2]  # Combined data\n@assert haskey(bindings, a)\n@assert haskey(bindings, b)\n@assert bindings[a].target == colimit_obj\n@assert bindings[b].target == colimit_obj\n@assert check_binding(colimit_obj, bindings, pat)\n@assert colimit_obj.id == :colimit  # Check colimit object name\n\n# Test colimit universal property\n@assert bindings[a].map(a.data) == [1, 2]\n@assert bindings[b].map(b.data) == [1, 2]\n@assert bindings[a].name == :injection_A  # Check injection morphism names\n@assert bindings[b].name == :injection_B","category":"page"},{"location":"categories/#Memory-Evolutive-Systems","page":"Categories","title":"Memory Evolutive Systems","text":"","category":"section"},{"location":"categories/#Mathematical-Definition-5","page":"Categories","title":"Mathematical Definition","text":"","category":"section"},{"location":"categories/","page":"Categories","title":"Categories","text":"A Memory Evolutive System (MES) consists of:","category":"page"},{"location":"categories/","page":"Categories","title":"Categories","text":"A category mathcalC of components and their relationships\nA hierarchy of complexity levels through colimit formation\nA dynamic structure through time evolution","category":"page"},{"location":"categories/","page":"Categories","title":"Categories","text":"The key operations include:","category":"page"},{"location":"categories/","page":"Categories","title":"Categories","text":"Pattern formation through selection of objects and morphisms\nColimit computation for complex component formation\nTemporal evolution through functorial transitions","category":"page"},{"location":"categories/#Implementation-5","page":"Categories","title":"Implementation","text":"","category":"section"},{"location":"categories/","page":"Categories","title":"Categories","text":"The MES implementation builds upon the previous structures:","category":"page"},{"location":"categories/","page":"Categories","title":"Categories","text":"Uses categories to represent system state\nEmploys patterns to identify meaningful subsystems\nComputes colimits to form higher-order components\nTracks temporal evolution through category morphisms","category":"page"},{"location":"categories/","page":"Categories","title":"Categories","text":"For example, creating a basic hierarchical structure:","category":"page"},{"location":"categories/","page":"Categories","title":"Categories","text":"# Create base level components\nA = Object(:A, \"base_component_1\")\nB = Object(:B, \"base_component_2\")\nf = Morphism(A, B, x -> process(x), :f)\n\n# Form a pattern\npattern = Pattern(category, [A, B], [f])\n\n# Compute colimit for higher-order component\ncolimit = find_colimit(pattern)","category":"page"},{"location":"categories/#Examples-5","page":"Categories","title":"Examples","text":"","category":"section"},{"location":"categories/","page":"Categories","title":"Categories","text":"using Moma\n\n# Create base level components\nneuron1 = Object(:N1, \"neuron_data_1\")\nneuron2 = Object(:N2, \"neuron_data_2\")\nsynapse = Morphism(neuron1, neuron2, \n                  x -> \"synapse_\" * x, :syn)\n@assert neuron1.id == :N1 && neuron1.data == \"neuron_data_1\"\n@assert neuron2.id == :N2 && neuron2.data == \"neuron_data_2\"\n@assert synapse.name == :syn\n@assert synapse.map(\"test\") == \"synapse_test\"\n\n# Create neural pattern\nneural_cat = Category([neuron1, neuron2], [synapse], :neural)\npattern = create_pattern(neural_cat, [neuron1, neuron2], [synapse])\n@assert neural_cat.name == :neural\n@assert length(neural_cat.objects) == 2\n@assert length(neural_cat.morphisms) == 1\n@assert length(pattern.objects) == 2\n@assert length(pattern.morphisms) == 1\n\n# Form higher-order component (neural assembly)\nassembly, bindings = find_colimit(pattern)\n\n# Verify the formation\n@assert check_binding(assembly, bindings, pattern)\n@assert assembly.id == :colimit  # Check assembly name\n@assert haskey(bindings, neuron1)\n@assert haskey(bindings, neuron2)\n@assert bindings[neuron1].name == :injection_N1  # Check injection morphism names\n@assert bindings[neuron2].name == :injection_N2","category":"page"},{"location":"categories/#Further-Reading","page":"Categories","title":"Further Reading","text":"","category":"section"},{"location":"categories/","page":"Categories","title":"Categories","text":"For more detailed mathematical background and applications:","category":"page"},{"location":"categories/","page":"Categories","title":"Categories","text":"MES23: Newer developments in Memory Evolutive Systems on human-machine interaction\nMES07: Memory Evolutive Systems (MES)\nMoMa25 Monetary Macro Accounting (MoMa) Theory (MoMaT)\nPapers: Complete list of related publications and theoretical background","category":"page"},{"location":"state_space_models/#State-Space-Model","page":"State Space Models","title":"State Space Model","text":"","category":"section"},{"location":"state_space_models/","page":"State Space Models","title":"State Space Models","text":"We switch from functions to functors for state transitions and states become categories, to be used for for a monetary macro accounting (MoMa).","category":"page"},{"location":"state_space_models/","page":"State Space Models","title":"State Space Models","text":"A usual way to model dynamics of economic systems are state space models. We will see now how to model state space model by functorial dynamics. In the next step we want to use this approach for macro accounting of money.  A first simply recursive version of MoMa25 in the Julia programming language. The code is in the file momascf_v02_en.jl.  It is a deterministic nonlinear model but still reduced form model.  Reduced form model is a economists way to say its a Markov decision process  not forward looking model which an economist would call a structural model.  Forward lookings models can be modeled as Open Games  but actually economic models should become MES systems where Open Games are coregulators.","category":"page"},{"location":"state_space_models/#State-Space-Model-as-MES","page":"State Space Models","title":"State Space Model as MES","text":"","category":"section"},{"location":"state_space_models/","page":"State Space Models","title":"State Space Models","text":"Traditional state space models represent system dynamics as simple vector-valued functions mapping states to states. While this approach is intuitive and computationally efficient, it has several limitations:","category":"page"},{"location":"state_space_models/","page":"State Space Models","title":"State Space Models","text":"Limited Expressiveness: Traditional state space models can only represent direct state-to-state mappings, making it difficult to model:\nComplex hierarchical relationships\nMultiple time scales\nEmergent properties\nMemory-dependent dynamics\nNo Built-in Structure: Standard state space models don't naturally capture:\nSystem composition\nComponent relationships\nTemporal dependencies\nMemory formation\nRigid Evolution: Conventional models often struggle with:\nAdaptive behavior\nSystem reconfiguration\nEmergent complexity\nMulti-level interactions","category":"page"},{"location":"state_space_models/","page":"State Space Models","title":"State Space Models","text":"The Memory Evolutive Systems (MES) framework, built on category theory, addresses these limitations by:","category":"page"},{"location":"state_space_models/","page":"State Space Models","title":"State Space Models","text":"Rich Mathematical Structure:\nObjects represent system components\nMorphisms capture relationships and transformations\nCategories organize system structure\nFunctors model system evolution\nBuilt-in Memory:\nExplicit representation of past states\nTemporal ordering through categorical structure\nMemory formation through colimits\nHistorical dependencies\nFlexible Composition:\nHierarchical organization\nComponent relationships\nSystem decomposition\nEmergent properties\nNatural Evolution:\nFunctorial dynamics\nAdaptive behavior\nSystem reconfiguration\nMulti-level interactions","category":"page"},{"location":"state_space_models/","page":"State Space Models","title":"State Space Models","text":"The following examples demonstrate these advantages in practice, showing how MES and category theory provide a more powerful framework for modeling complex dynamical systems.","category":"page"},{"location":"state_space_models/#Memory","page":"State Space Models","title":"Memory","text":"","category":"section"},{"location":"state_space_models/","page":"State Space Models","title":"State Space Models","text":"The TimeSeriesMemory type provides a structured way to store and manage time series data with explicit temporal relationships between states. It maintains three key components:","category":"page"},{"location":"state_space_models/","page":"State Space Models","title":"State Space Models","text":"times: Vector of time points\nstates: Vector of state values\nlinks: Vector of morphisms connecting consecutive states","category":"page"},{"location":"state_space_models/#Core-Functions","page":"State Space Models","title":"Core Functions","text":"","category":"section"},{"location":"state_space_models/","page":"State Space Models","title":"State Space Models","text":"# Create a new time series memory\nTimeSeriesMemory(initial_time::Object{Float64}, initial_state::Object{T})\n\n# Extend memory with new time point and state\nextend!(memory::TimeSeriesMemory{T}, new_time::Object{Float64}, new_state::Object{T}, link::Morphism)\n\n# Access memory components\nget_data(memory::TimeSeriesMemory)::Vector{T}\nget_times(memory::TimeSeriesMemory)::Vector{Float64}\nget_links(memory::TimeSeriesMemory)::Vector{Morphism}","category":"page"},{"location":"state_space_models/#Example","page":"State Space Models","title":"Example","text":"","category":"section"},{"location":"state_space_models/","page":"State Space Models","title":"State Space Models","text":"# Create initial memory\nt₁ = Object(:t1, 1.0)\ns₁ = Object(:s1, [1.0])\nmemory = TimeSeriesMemory(t₁, s₁)\n\n# Verify initial state\n@assert length(memory.times) == 1\n@assert length(memory.states) == 1\n@assert length(memory.links) == 0\n\n# Extend memory with new state\nt₂ = Object(:t2, 2.0)\ns₂ = Object(:s2, [2.0])\nlink = Morphism(s₁, s₂, x -> 2.0 * x, :link)\nextend!(memory, t₂, s₂, link)\n\n# Verify extended state\n@assert length(memory.times) == 2\n@assert length(memory.states) == 2\n@assert length(memory.links) == 1\n\n# Access memory components\ndata = get_data(memory)\ntimes = get_times(memory)\nlinks = get_links(memory)\n\n# Verify data types and values\n@assert length(data) == 2\n@assert length(times) == 2\n@assert length(links) == 1\n@assert all(x -> x isa Vector{Float64}, data)\n@assert all(x -> x isa Float64, times)\n@assert all(x -> x isa Morphism, links)\n@assert data[1] == [1.0]\n@assert data[2] == [2.0]\n@assert times[1] == 1.0\n@assert times[2] == 2.0","category":"page"},{"location":"state_space_models/#AR(1)-Model","page":"State Space Models","title":"AR(1) Model","text":"","category":"section"},{"location":"state_space_models/","page":"State Space Models","title":"State Space Models","text":"The first-order autoregressive model represents a simple state space model where the next state depends linearly on the current state:","category":"page"},{"location":"state_space_models/","page":"State Space Models","title":"State Space Models","text":"x_t+1 = alpha x_t","category":"page"},{"location":"state_space_models/","page":"State Space Models","title":"State Space Models","text":"where alpha is the autoregression coefficient.","category":"page"},{"location":"state_space_models/#Implementation","page":"State Space Models","title":"Implementation","text":"","category":"section"},{"location":"state_space_models/","page":"State Space Models","title":"State Space Models","text":"The AR(1) model is implemented using the following functions:","category":"page"},{"location":"state_space_models/","page":"State Space Models","title":"State Space Models","text":"function create_ar_model(initial_state::Vector{Float64})\n    t₁ = Object(:t1, 1.0)\n    s₁ = Object(:s1, initial_state)\n\n    time_step = Morphism(t₁, Object(:t2, 2.0), t -> t + 1.0, :time_step)\n    evolution = Morphism(s₁, Object(:s2, [0.0]), x -> [0.7 * x[1]], :evolution)\n\n    return t₁, s₁, time_step, evolution\nend","category":"page"},{"location":"state_space_models/","page":"State Space Models","title":"State Space Models","text":"This implementation uses category theory concepts:","category":"page"},{"location":"state_space_models/","page":"State Space Models","title":"State Space Models","text":"Objects represent time points and states\nMorphisms represent the evolution of time and states\nThe time step morphism maps each time point to the next one\nThe evolution morphism implements the AR(1) equation x_t+1 = alpha x_t with alpha = 07","category":"page"},{"location":"state_space_models/#Example-2","page":"State Space Models","title":"Example","text":"","category":"section"},{"location":"state_space_models/","page":"State Space Models","title":"State Space Models","text":"# Create and simulate AR(1) model\nt₁, s₁, time_step, evolution = create_ar_model([0.5])\nmemory = simulate_dynamics(t₁, s₁, time_step, evolution, 5)\n\n# Verify the model behavior\n@test s₁.data == [0.5]\n@test time_step.map(1.0) == 2.0\n@test evolution.map([0.5]) == [0.35]","category":"page"},{"location":"state_space_models/#VAR(1)-Model","page":"State Space Models","title":"VAR(1) Model","text":"","category":"section"},{"location":"state_space_models/","page":"State Space Models","title":"State Space Models","text":"The first-order vector autoregressive model extends the AR(1) model to multiple dimensions:","category":"page"},{"location":"state_space_models/","page":"State Space Models","title":"State Space Models","text":"mathbfx_t+1 = Amathbfx_t","category":"page"},{"location":"state_space_models/","page":"State Space Models","title":"State Space Models","text":"where A is the coefficient matrix and mathbfx_t is a vector of states.","category":"page"},{"location":"state_space_models/#Implementation-2","page":"State Space Models","title":"Implementation","text":"","category":"section"},{"location":"state_space_models/","page":"State Space Models","title":"State Space Models","text":"The VAR(1) model is implemented using:","category":"page"},{"location":"state_space_models/","page":"State Space Models","title":"State Space Models","text":"function create_var_model(initial_state::Vector{Float64}, A::Matrix{Float64})\n    t₁ = Object(:t1, 1.0)\n    s₁ = Object(:s1, initial_state)\n\n    time_step = Morphism(t₁, Object(:t2, 2.0), t -> t + 1.0, :time_step)\n    evolution = Morphism(s₁, Object(:s2, similar(initial_state)), x -> A * x, :evolution)\n\n    return t₁, s₁, time_step, evolution\nend","category":"page"},{"location":"state_space_models/","page":"State Space Models","title":"State Space Models","text":"This implementation extends the AR(1) model to multiple dimensions:","category":"page"},{"location":"state_space_models/","page":"State Space Models","title":"State Space Models","text":"Uses the same categorical structure with Objects and Morphisms\nThe evolution morphism implements the VAR(1) equation mathbfx_t+1 = Amathbfx_t\nMatrix multiplication is used to compute the next state vector","category":"page"},{"location":"state_space_models/#Example-3","page":"State Space Models","title":"Example","text":"","category":"section"},{"location":"state_space_models/","page":"State Space Models","title":"State Space Models","text":"# Create and simulate VAR(1) model\nA = [0.5 0.2; 0.1 0.6]\nt₁, s₁, time_step, evolution = create_var_model([1.0, 2.0], A)\nmemory = simulate_dynamics(t₁, s₁, time_step, evolution, 100)\n\n# Verify the model behavior\n@test s₁.data == [1.0, 2.0]\n@test evolution.map([1.0, 2.0]) .== A * [1.0, 2.0]","category":"page"},{"location":"state_space_models/#Nonlinear-VAR-Model","page":"State Space Models","title":"Nonlinear VAR Model","text":"","category":"section"},{"location":"state_space_models/","page":"State Space Models","title":"State Space Models","text":"The nonlinear VAR model introduces nonlinear transformations to the state evolution:","category":"page"},{"location":"state_space_models/","page":"State Space Models","title":"State Space Models","text":"mathbfx_t+1 = f(Amathbfx_t)","category":"page"},{"location":"state_space_models/","page":"State Space Models","title":"State Space Models","text":"where f is a nonlinear function applied element-wise.","category":"page"},{"location":"state_space_models/#Implementation-3","page":"State Space Models","title":"Implementation","text":"","category":"section"},{"location":"state_space_models/","page":"State Space Models","title":"State Space Models","text":"The nonlinear VAR model is implemented using:","category":"page"},{"location":"state_space_models/","page":"State Space Models","title":"State Space Models","text":"function create_nonlinear_var_model(initial_state::Vector{Float64}, A::Matrix{Float64})\n    t₁ = Object(:t1, 1.0)\n    s₁ = Object(:s1, initial_state)\n\n    time_step = Morphism(t₁, Object(:t2, 2.0), t -> t + 1.0, :time_step)\n    evolution = Morphism(s₁, Object(:s2, similar(initial_state)), x -> A * x + 0.1 * sin.(x), :evolution)\n\n    return t₁, s₁, time_step, evolution\nend","category":"page"},{"location":"state_space_models/","page":"State Space Models","title":"State Space Models","text":"This implementation adds nonlinearity to the VAR model:","category":"page"},{"location":"state_space_models/","page":"State Space Models","title":"State Space Models","text":"Maintains the same categorical structure\nThe evolution morphism combines linear transformation with nonlinear sine function\nThe nonlinear term 01sin(mathbfx) is applied element-wise to the state vector","category":"page"},{"location":"state_space_models/#Example-4","page":"State Space Models","title":"Example","text":"","category":"section"},{"location":"state_space_models/","page":"State Space Models","title":"State Space Models","text":"# Create and simulate nonlinear VAR model\nt₁, s₁, time_step, evolution = create_nonlinear_var_model([1.0, 0.5], A)\nmemory = simulate_dynamics(t₁, s₁, time_step, evolution, 100)\n\n# Verify the model behavior\n@test s₁.data == [1.0, 0.5]\n@test evolution.map isa Function\nresult = evolution.map([1.0, 0.5])\n@test length(result) == 2\n@test all(isfinite, result)","category":"page"},{"location":"state_space_models/#Stochastic-Nonlinear-VAR-Model","page":"State Space Models","title":"Stochastic Nonlinear VAR Model","text":"","category":"section"},{"location":"state_space_models/","page":"State Space Models","title":"State Space Models","text":"The stochastic nonlinear VAR model adds random components to the state evolution:","category":"page"},{"location":"state_space_models/","page":"State Space Models","title":"State Space Models","text":"mathbfx_t+1 = f(Amathbfx_t) + boldsymbolepsilon_t","category":"page"},{"location":"state_space_models/","page":"State Space Models","title":"State Space Models","text":"where boldsymbolepsilon_t is a random noise vector.","category":"page"},{"location":"state_space_models/#Implementation-4","page":"State Space Models","title":"Implementation","text":"","category":"section"},{"location":"state_space_models/","page":"State Space Models","title":"State Space Models","text":"The stochastic nonlinear VAR model is implemented using:","category":"page"},{"location":"state_space_models/","page":"State Space Models","title":"State Space Models","text":"function create_stochastic_nonlinear_var_model(initial_state::Vector{Float64}, A::Matrix{Float64})\n    t₁ = Object(:t1, 1.0)\n    s₁ = Object(:s1, initial_state)\n\n    time_step = Morphism(t₁, Object(:t2, 2.0), t -> t + 1.0, :time_step)\n    evolution = Morphism(s₁, Object(:s2, similar(initial_state)), \n                        x -> A * x + 0.1 * sin.(x) + 0.1 * randn(length(x)), :evolution)\n\n    return t₁, s₁, time_step, evolution\nend","category":"page"},{"location":"state_space_models/","page":"State Space Models","title":"State Space Models","text":"This implementation adds stochasticity to the nonlinear VAR model:","category":"page"},{"location":"state_space_models/","page":"State Space Models","title":"State Space Models","text":"Uses the same categorical structure\nThe evolution morphism combines:\nLinear transformation Amathbfx\nNonlinear term 01sin(mathbfx)\nRandom noise 01boldsymbolepsilon where boldsymbolepsilon sim mathcalN(01)\nEach call to the evolution morphism produces a different result due to the random component","category":"page"},{"location":"state_space_models/#Example-5","page":"State Space Models","title":"Example","text":"","category":"section"},{"location":"state_space_models/","page":"State Space Models","title":"State Space Models","text":"# Create and simulate stochastic nonlinear VAR model\nt₁, s₁, time_step, evolution = create_stochastic_nonlinear_var_model([1.0, 0.5], A)\nmemory = simulate_dynamics(t₁, s₁, time_step, evolution, 100)\n\n# Verify the model behavior\n@test s₁.data == [1.0, 0.5]\n@test evolution.map isa Function\nresults = [evolution.map([1.0, 0.5]) for _ in 1:10]\n@test all(x -> length(x) == 2, results)\n@test all(x -> all(isfinite, x), results)\n@test length(unique(results)) > 1  # Ensure stochastic behavior","category":"page"},{"location":"state_space_models/#Visualization","page":"State Space Models","title":"Visualization","text":"","category":"section"},{"location":"state_space_models/","page":"State Space Models","title":"State Space Models","text":"The state space models can be visualized using the following functions:","category":"page"},{"location":"state_space_models/","page":"State Space Models","title":"State Space Models","text":"# Create time series plots for each model\np1 = plot_timeseries(ar1_memory, \"Deterministic Linear AR(1)\")\np2 = plot_timeseries(var1_memory, \"Deterministic Linear VAR(1)\")\np3 = plot_timeseries(nonlinear_memory, \"Deterministic Nonlinear VAR\")\np4 = plot_timeseries(stochastic_memory, \"Stochastic Nonlinear VAR\")\n\n# Create comparison plot\ncomparison_plot = plot(p1, p2, p3, p4, layout=(2, 2), size=(1000, 1000))\nsavefig(comparison_plot, \"dynamics_comparison.png\")","category":"page"},{"location":"state_space_models/","page":"State Space Models","title":"State Space Models","text":"(Image: Comparison of different state space models)","category":"page"},{"location":"state_space_models/#Implementation-Details","page":"State Space Models","title":"Implementation Details","text":"","category":"section"},{"location":"state_space_models/","page":"State Space Models","title":"State Space Models","text":"The following code snippets show the core implementation of the state space models in the statespace.jl file:","category":"page"},{"location":"state_space_models/#Time-Series-Memory-Structure","page":"State Space Models","title":"Time Series Memory Structure","text":"","category":"section"},{"location":"state_space_models/","page":"State Space Models","title":"State Space Models","text":"struct TimeSeriesMemory{T}\n    times::Vector{Object{Float64}}\n    states::Vector{Object{T}}\n    links::Vector{Morphism{T,T}}\n\n    function TimeSeriesMemory{T}(initial_time::Object{Float64}, initial_state::Object{T}) where {T}\n        new{T}([initial_time], [initial_state], Morphism{T,T}[])\n    end\nend","category":"page"},{"location":"state_space_models/#Core-Functions-2","page":"State Space Models","title":"Core Functions","text":"","category":"section"},{"location":"state_space_models/","page":"State Space Models","title":"State Space Models","text":"function extend!(memory::TimeSeriesMemory{T}, new_time::Object{Float64}, new_state::Object{T}, link::Morphism{T,T}) where {T}\n    push!(memory.times, new_time)\n    push!(memory.states, new_state)\n    push!(memory.links, link)\nend\n\nfunction get_data(memory::TimeSeriesMemory{T}) where {T}\n    return [state.data for state in memory.states]\nend\n\nfunction get_times(memory::TimeSeriesMemory{T}) where {T}\n    return [t.data for t in memory.times]\nend\n\nfunction get_links(memory::TimeSeriesMemory{T}) where {T}\n    return memory.links\nend","category":"page"},{"location":"state_space_models/#Data-Collection-and-Visualization","page":"State Space Models","title":"Data Collection and Visualization","text":"","category":"section"},{"location":"state_space_models/","page":"State Space Models","title":"State Space Models","text":"function collect_timeseries(memory::TimeSeriesMemory{T}) where {T}\n    return (get_times(memory), get_data(memory))\nend\n\nfunction plot_timeseries(memory::TimeSeriesMemory{T}, title::String=\"Time Series\") where {T}\n    times, data = collect_timeseries(memory)\n\n    # Handle both scalar and vector states\n    if data[1] isa Vector\n        n_vars = length(data[1])\n        p = plot(title=title, xlabel=\"Time\", ylabel=\"Value\")\n        for i in 1:n_vars\n            plot!(p, times, [d[i] for d in data], label=\"Variable $i\")\n        end\n    else\n        p = plot(times, data, title=title, xlabel=\"Time\", ylabel=\"Value\")\n    end\n\n    return p\nend","category":"page"},{"location":"state_space_models/#Model-Creation-Functions","page":"State Space Models","title":"Model Creation Functions","text":"","category":"section"},{"location":"state_space_models/","page":"State Space Models","title":"State Space Models","text":"function create_ar_model(initial_state::Vector{Float64})\n    t₁ = Object(:t1, 1.0)\n    s₁ = Object(:s1, initial_state)\n\n    time_step = Morphism(t₁, Object(:t2, 2.0), t -> t + 1.0, :time_step)\n    evolution = Morphism(s₁, Object(:s2, [0.0]), x -> [0.7 * x[1]], :evolution)\n\n    return t₁, s₁, time_step, evolution\nend\n\nfunction create_var_model(initial_state::Vector{Float64}, A::Matrix{Float64})\n    t₁ = Object(:t1, 1.0)\n    s₁ = Object(:s1, initial_state)\n\n    time_step = Morphism(t₁, Object(:t2, 2.0), t -> t + 1.0, :time_step)\n    evolution = Morphism(s₁, Object(:s2, similar(initial_state)), x -> A * x, :evolution)\n\n    return t₁, s₁, time_step, evolution\nend\n\nfunction create_nonlinear_var_model(initial_state::Vector{Float64}, A::Matrix{Float64})\n    t₁ = Object(:t1, 1.0)\n    s₁ = Object(:s1, initial_state)\n\n    time_step = Morphism(t₁, Object(:t2, 2.0), t -> t + 1.0, :time_step)\n    evolution = Morphism(s₁, Object(:s2, similar(initial_state)), x -> A * x + 0.1 * sin.(x), :evolution)\n\n    return t₁, s₁, time_step, evolution\nend","category":"page"},{"location":"state_space_models/#Dynamics-Simulation","page":"State Space Models","title":"Dynamics Simulation","text":"","category":"section"},{"location":"state_space_models/","page":"State Space Models","title":"State Space Models","text":"function simulate_dynamics(t₁::Object{Float64}, s₁::Object{T}, time_step::Morphism, evolution::Morphism, n_steps::Int) where {T}\n    memory = TimeSeriesMemory{T}(t₁, s₁)\n    \n    for i in 1:n_steps\n        t_next = Object(Symbol(\"t$(i+1)\"), time_step.map(memory.times[end].data))\n        s_next = Object(Symbol(\"s$(i+1)\"), evolution.map(memory.states[end].data))\n        link = Morphism(memory.states[end], s_next, evolution.map, Symbol(\"link$i\"))\n        extend!(memory, t_next, s_next, link)\n    end\n    \n    return memory\nend","category":"page"},{"location":"mes07/#MES07:-Memory-Evolutive-Systems","page":"MES07: Memory Evolutive Systems","title":"MES07: Memory Evolutive Systems","text":"","category":"section"},{"location":"mes07/#Overview","page":"MES07: Memory Evolutive Systems","title":"Overview","text":"","category":"section"},{"location":"mes07/","page":"MES07: Memory Evolutive Systems","title":"MES07: Memory Evolutive Systems","text":"This foundational paper introduces Memory Evolutive Systems (MES) as mathematical models for autonomous evolutionary systems, particularly focusing on biological and social systems, including nervous systems of higher animals. The work is rooted in category theory and represents two decades of research development.","category":"page"},{"location":"mes07/#Key-Concepts","page":"MES07: Memory Evolutive Systems","title":"Key Concepts","text":"","category":"section"},{"location":"mes07/#Complexity-Characterization","page":"MES07: Memory Evolutive Systems","title":"Complexity Characterization","text":"","category":"section"},{"location":"mes07/","page":"MES07: Memory Evolutive Systems","title":"MES07: Memory Evolutive Systems","text":"The paper addresses three fundamental problems:","category":"page"},{"location":"mes07/","page":"MES07: Memory Evolutive Systems","title":"MES07: Memory Evolutive Systems","text":"The Binding Problem: How simple objects combine to form a \"whole greater than the sum of its parts\"\nThe Emergence Problem: How properties of complex objects relate to their elementary components\nThe Hierarchy Problem: Explaining the formation of increasingly complex objects, from elementary particles to societies","category":"page"},{"location":"mes07/#Self-Regulation","page":"MES07: Memory Evolutive Systems","title":"Self-Regulation","text":"","category":"section"},{"location":"mes07/","page":"MES07: Memory Evolutive Systems","title":"MES07: Memory Evolutive Systems","text":"The paper introduces key characteristics that allow for autonomy through self-regulation:","category":"page"},{"location":"mes07/","page":"MES07: Memory Evolutive Systems","title":"MES07: Memory Evolutive Systems","text":"Internal regulation systems\nCapacity to recognize environmental characteristics\nDevelopment of appropriate responses\nIntroduction of co-regulators (CR) for different hierarchy levels\nFlexible memory systems for adaptation","category":"page"},{"location":"mes07/#Cognitive-Systems","page":"MES07: Memory Evolutive Systems","title":"Cognitive Systems","text":"","category":"section"},{"location":"mes07/","page":"MES07: Memory Evolutive Systems","title":"MES07: Memory Evolutive Systems","text":"The paper explores applications to:","category":"page"},{"location":"mes07/","page":"MES07: Memory Evolutive Systems","title":"MES07: Memory Evolutive Systems","text":"Nervous system modeling\nCognition processes\nConsciousness modeling\nDevelopment of personal memory (archetypal core)","category":"page"},{"location":"mes07/#Mathematical-Framework","page":"MES07: Memory Evolutive Systems","title":"Mathematical Framework","text":"","category":"section"},{"location":"mes07/","page":"MES07: Memory Evolutive Systems","title":"MES07: Memory Evolutive Systems","text":"The model uses:","category":"page"},{"location":"mes07/","page":"MES07: Memory Evolutive Systems","title":"MES07: Memory Evolutive Systems","text":"Category theory as the foundational mathematical structure\nComplex systems theory\nHierarchical evolutive systems based on colimit concepts\nNetwork theory for co-regulator interactions","category":"page"},{"location":"mes07/#Applications","page":"MES07: Memory Evolutive Systems","title":"Applications","text":"","category":"section"},{"location":"mes07/","page":"MES07: Memory Evolutive Systems","title":"MES07: Memory Evolutive Systems","text":"The framework has applications in:","category":"page"},{"location":"mes07/","page":"MES07: Memory Evolutive Systems","title":"MES07: Memory Evolutive Systems","text":"Biology\nMedicine\nSociology\nEcology\nEconomics\nComplex systems analysis","category":"page"},{"location":"mes07/#Historical-Context","page":"MES07: Memory Evolutive Systems","title":"Historical Context","text":"","category":"section"},{"location":"mes07/","page":"MES07: Memory Evolutive Systems","title":"MES07: Memory Evolutive Systems","text":"The work emerged from a collaboration between:","category":"page"},{"location":"mes07/","page":"MES07: Memory Evolutive Systems","title":"MES07: Memory Evolutive Systems","text":"Jean-Paul Vanbremeersch (physician specializing in gerontology)\nAndrée C. Ehresmann (mathematician)","category":"page"},{"location":"mes07/","page":"MES07: Memory Evolutive Systems","title":"MES07: Memory Evolutive Systems","text":"Their collaboration began in 1980, leading to the development of MES theory.","category":"page"},{"location":"geometric_system/#Geometric-System","page":"Geometric System","title":"Geometric System","text":"","category":"section"},{"location":"geometric_system/","page":"Geometric System","title":"Geometric System","text":"Category theory provides a powerful framework for handling geometric systems by offering a structured way to represent and manipulate geometric objects and their relationships. This approach has several key benefits:","category":"page"},{"location":"geometric_system/","page":"Geometric System","title":"Geometric System","text":"Structured Representation: Geometric objects (points, lines, shapes) can be represented as objects in a category, while geometric transformations (translations, rotations, scaling) are represented as morphisms between these objects.\nComposition of Transformations: Category theory's composition rules naturally capture how geometric transformations can be combined. For example, a rotation followed by a translation can be represented as the composition of two morphisms.\nInvariant Properties: The categorical framework helps maintain geometric invariants. For instance, when we define a morphism that transforms a point into a line, we can ensure it preserves important geometric properties.\nPattern Recognition: Categories allow us to identify and work with geometric patterns as subcategories, making it easier to recognize and manipulate recurring geometric structures.\nHierarchical Organization: Complex geometric systems can be organized hierarchically using categories and subcategories, reflecting the natural structure of geometric relationships.","category":"page"},{"location":"geometric_system/","page":"Geometric System","title":"Geometric System","text":"The following example demonstrates how we can implement these concepts using our category theory framework:","category":"page"},{"location":"geometric_system/","page":"Geometric System","title":"Geometric System","text":"using Moma\n\n# Define custom data types for geometric objects\n# Point represents a 2D point with x and y coordinates\nstruct Point\n    x::Float64\n    y::Float64\nend\n\n# Line represents a line segment with start and end points\nstruct Line\n    start::Point\n    ends::Point\nend\n\n# Create objects in our category using the custom data types\n# Each object has a unique identifier (symbol) and associated data\np1 = Object(:P1, Point(0.0, 0.0))  # Point at origin\np2 = Object(:P2, Point(1.0, 1.0))  # Point at (1,1)\nl1 = Object(:L1, Line(Point(0.0, 0.0), Point(1.0, 1.0)))  # Line from origin to (1,1)\n\n# Verify that objects are created correctly by checking their data\n# This ensures our objects maintain their geometric properties\n@assert p1.data.x == 0.0\n@assert p1.data.y == 0.0\n@assert p2.data.x == 1.0\n@assert p2.data.y == 1.0\n@assert l1.data.start.x == 0.0\n@assert l1.data.start.y == 0.0\n@assert l1.data.ends.x == 1.0\n@assert l1.data.ends.y == 1.0\n@assert p1.id == :P1\n@assert p2.id == :P2\n@assert l1.id == :L1\n\n# Create a morphism that transforms a point into a line\n# This morphism takes a point and creates a line from that point to a point 1 unit right and up\nf = Morphism(p1, l1, p -> Line(p, Point(p.x + 1.0, p.y + 1.0)), :f)\n\n# Verify that the morphism correctly transforms the point into a line\n# This ensures our morphisms preserve geometric relationships\nresult = f.map(p1.data)\n@assert result.start.x == 0.0\n@assert result.start.y == 0.0\n@assert result.ends.x == 1.0\n@assert result.ends.y == 1.0\n@assert f.id == :f\n@assert f.source == p1\n@assert f.target == l1\n\n# Create a category that contains our geometric objects and morphisms\n# This category represents our geometric system\ngeom_cat = Category([p1, p2, l1], [f], :Geometry)\n@assert length(geom_cat.objects) == 3\n@assert length(geom_cat.morphisms) == 1\n@assert geom_cat.id == :Geometry\n@assert p1 in geom_cat.objects\n@assert p2 in geom_cat.objects\n@assert l1 in geom_cat.objects\n@assert f in geom_cat.morphisms\n\n# Create a pattern within our geometric category\n# A pattern is a subcategory that represents a specific geometric configuration\n# Here we create a pattern with a point and a line, connected by our morphism\ngeom_pattern = create_pattern(geom_cat, [p1, l1], [f])\n@assert length(geom_pattern.objects) == 2\n@assert length(geom_pattern.morphisms) == 1\n@assert geom_pattern.category == geom_cat\n@assert p1 in geom_pattern.objects\n@assert l1 in geom_pattern.objects\n@assert f in geom_pattern.morphisms","category":"page"},{"location":"geometric_system/","page":"Geometric System","title":"Geometric System","text":"","category":"page"},{"location":"api/#API-Reference","page":"API","title":"API Reference","text":"","category":"section"},{"location":"api/#Overview","page":"API","title":"Overview","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"The Categories module provides implementations of fundamental category theory concepts used in Memory Evolutive Systems (MES). This includes:","category":"page"},{"location":"api/","page":"API","title":"API","text":"Basic categorical constructions (objects, morphisms, categories)\nFunctorial mappings between categories\nNatural transformations between functors\nPattern (diagram) creation and manipulation\nColimit computation and verification","category":"page"},{"location":"api/#Type-Parameters","page":"API","title":"Type Parameters","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Many types in the module are parameterized to allow for flexible data types:","category":"page"},{"location":"api/","page":"API","title":"API","text":"Object{T}: T can be any type\nMorphism{S,T}: S is the source object's data type, T is the target object's data type\nMemory{T}: T is the type of the state data","category":"page"},{"location":"api/","page":"API","title":"API","text":"This allows for creating categories with heterogeneous data types while maintaining type safety.","category":"page"},{"location":"api/","page":"API","title":"API","text":"Functions in the module may throw the following errors:","category":"page"},{"location":"api/","page":"API","title":"API","text":"MorphismCompositionError: When morphisms are not composable\nMorphismNotInCategoryError: When morphisms don't belong to a category\nObjectNotInCategoryError: When objects don't belong to a category\nObjectNotInCategory: When pattern creation fails due to invalid object input.\nMorphismNotInCategory: When pattern creation fails due to invalid morphism input.\nPatternMustHaveAtLeastOneObject: When pattern has not Object.\nPatternMustHaveAtLeastOneObject: When find colimit fails due to no objects in pattern.\nErrorException: When colimit construction fails\nErrorException: When simulation parameters are invalid\nErrorException: When plotting data is malformed","category":"page"},{"location":"api/#Modules","page":"API","title":"Modules","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Source: src/Categories.jl and src/statespace.jl","category":"page"},{"location":"api/","page":"API","title":"API","text":"Modules = [Moma.Categories, Moma.StateSpace]\nOrder = [:module]","category":"page"},{"location":"api/#Moma.Categories","page":"API","title":"Moma.Categories","text":"module Categories\n\nThis module provides basic categorical constructions used in Memory Evolutive Systems (MES). It includes implementations of objects, morphisms, categories, functors, natural transformations, and patterns, along with functions for working with these constructions.\n\nMathematical Background\n\nThe module implements core concepts from category theory:\n\nObjects and morphisms form categories with composition and identity laws\nFunctors preserve structure between categories\nNatural transformations connect functors\nColimits represent universal constructions\n\nExports\n\nObject: Represents an object in a category\nMorphism: Represents a morphism between objects\nCategory: Represents a category with objects and morphisms\nFunctor: Represents a functor between categories\nNaturalTransformation: Represents a natural transformation between functors\nPattern: Represents a pattern (diagram) in a category\nidentity_morphism: Creates an identity morphism for an object\ncompose: Composes two morphisms\ncreate_pattern: Creates a pattern from objects and morphisms\ncheck_binding: Checks if an object forms a colimit for a pattern\nfind_colimit: Finds or constructs colimits for patterns\nis_morphism_in_category: Checks if a morphism belongs to a category\nMorphismCompositionError: Represents an error when composing morphisms\n\n\n\n\n\n","category":"module"},{"location":"api/#Moma.StateSpace","page":"API","title":"Moma.StateSpace","text":"module StateSpace\n\nThis module provides implementations of state space models using Memory Evolutive Systems (MES) concepts. It includes:\n\nTime series memory management\nState space model implementations (AR, VAR, nonlinear VAR)\nSimulation and visualization tools\nData collection and analysis utilities\n\nMathematical Background\n\nThe module implements state space models using categorical tools:\n\nTime series as sequences of objects and morphisms\nState transitions as morphisms between objects\nMemory as a structured collection of states and transitions\nVisualization of system dynamics\n\nExports\n\nTimeSeriesMemory: Type for storing time series data\nextend!: Extend memory with new time point and state\nget_data, get_times, get_links: Access memory components\ncollect_timeseries, plot_timeseries: Data collection and visualization\ncreate_ar_model, create_var_model: Model creation functions\nsimulate_dynamics: System simulation\n\n\n\n\n\n","category":"module"},{"location":"api/#Types","page":"API","title":"Types","text":"","category":"section"},{"location":"api/#Basic-Types","page":"API","title":"Basic Types","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Source: src/Categories.jl and src/statespace.jl","category":"page"},{"location":"api/","page":"API","title":"API","text":"Moma.Categories.Object\nMoma.Categories.Morphism\nMoma.Categories.Category\nMoma.StateSpace.TimeSeriesMemory","category":"page"},{"location":"api/#Moma.Categories.Object","page":"API","title":"Moma.Categories.Object","text":"Object{T}\n\nRepresents an object in a category.\n\nType Parameters\n\nT: The type of data associated with the object\n\nFields\n\nid::Symbol: Unique identifier for the object\ndata::T: Data associated with the object\n\nExamples\n\n# Create an object with string data\nobj = Object(:A, \"data\")\n\n# Create an object with numeric data\nnum_obj = Object(:B, 42)\n\n# Create an object with custom type\nstruct Point\n    x::Float64\n    y::Float64\nend\npoint_obj = Object(:P, Point(0.0, 1.0))\n\n\n\n\n\n","category":"type"},{"location":"api/#Moma.Categories.Morphism","page":"API","title":"Moma.Categories.Morphism","text":"Morphism{S,T}\n\nRepresents a morphism between objects in a category.\n\nType Parameters\n\nS: The type of data in the source object\nT: The type of data in the target object\n\nFields\n\nsource::Object{S}: Source object\ntarget::Object{T}: Target object\nmap::Function: Function mapping source to target\nid::Symbol: Unique identifier for the morphism\n\nExamples\n\n# Create objects\nA = Object(:A, \"hello\")\nB = Object(:B, \"HELLO\")\n\n# Create a morphism that uppercases strings\nf = Morphism(A, B, uppercase, :f)\n@assert f.map(A.data) == B.data\n\n# Create a morphism between numeric objects\nX = Object(:X, 1)\nY = Object(:Y, 2)\ng = Morphism(X, Y, x -> x + 1, :g)\n\n\n\n\n\n","category":"type"},{"location":"api/#Moma.Categories.Category","page":"API","title":"Moma.Categories.Category","text":"Category\n\nRepresents a category with objects and morphisms.\n\nFields\n\nobjects::Vector{<:Object}: Objects in the category\nmorphisms::Vector{<:Morphism}: Morphisms in the category\nid::Symbol: Unique identifier for the category\n\n\n\n\n\n","category":"type"},{"location":"api/#Moma.StateSpace.TimeSeriesMemory","page":"API","title":"Moma.StateSpace.TimeSeriesMemory","text":"TimeSeriesMemory{T}\n\nA type for storing time series data in a Memory Evolutive Systems (MES) style.\n\nType Parameters\n\nT: The type of data stored in each state (e.g., Float64, Vector{Float64})\n\nFields\n\ntimes::Vector{Object{Float64}}: Time objects representing the temporal dimension\nstates::Vector{Object{T}}: State objects representing the system's evolution\nlinks::Vector{Morphism{T,T}}: Links between consecutive states (morphisms)\n\nConstructors\n\n# Create memory with scalar states\nt₁ = Object(:t1, 1.0)\ns₁ = Object(:s1, 1.0)\nmemory = TimeSeriesMemory(t₁, s₁)\n\n# Create memory with vector states\nt₁ = Object(:t1, 1.0)\ns₁ = Object(:s1, [1.0, 2.0])\nmemory = TimeSeriesMemory(t₁, s₁)\n\n\n\n\n\n","category":"type"},{"location":"api/#Advanced-Types","page":"API","title":"Advanced Types","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Source: src/Categories.jl","category":"page"},{"location":"api/","page":"API","title":"API","text":"Moma.Categories.Functor\nMoma.Categories.NaturalTransformation\nMoma.Categories.Pattern","category":"page"},{"location":"api/#Moma.Categories.Functor","page":"API","title":"Moma.Categories.Functor","text":"Functor\n\nRepresents a functor between categories.\n\nFields\n\nsource::Category: Source category\ntarget::Category: Target category\nobject_map::Dict{<:Object,<:Object}: Mapping of objects\nmorphism_map::Dict{<:Morphism,<:Morphism}: Mapping of morphisms\nid::Symbol: Unique identifier for the functor\n\n\n\n\n\n","category":"type"},{"location":"api/#Moma.Categories.NaturalTransformation","page":"API","title":"Moma.Categories.NaturalTransformation","text":"NaturalTransformation\n\nRepresents a natural transformation between functors.\n\nFields\n\nsource::Functor: Source functor\ntarget::Functor: Target functor\ncomponents::Dict{<:Object,<:Morphism}: Component morphisms\nid::Symbol: Unique identifier for the natural transformation\n\n\n\n\n\n","category":"type"},{"location":"api/#Moma.Categories.Pattern","page":"API","title":"Moma.Categories.Pattern","text":"Pattern\n\nRepresents a pattern (diagram) in a category.\n\nFields\n\ncategory::Category: The category containing the pattern\nobjects::Vector{<:Object}: Objects in the pattern\nmorphisms::Vector{<:Morphism}: Morphisms in the pattern\nid::Symbol: Unique identifier for the pattern\n\n\n\n\n\n","category":"type"},{"location":"api/#Error-Handling","page":"API","title":"Error Handling","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Source: src/Categories.jl","category":"page"},{"location":"api/","page":"API","title":"API","text":"Moma.Categories.ObjectNotInCategoryError\nMoma.Categories.MorphismNotInCategoryError\nMoma.Categories.MorphismCompositionError\nMoma.Categories.PatternHasNoBindingError\nMoma.Categories.PatternMustHaveAtLeastOneObject","category":"page"},{"location":"api/#Moma.Categories.ObjectNotInCategoryError","page":"API","title":"Moma.Categories.ObjectNotInCategoryError","text":"ObjectNotInCategoryError <: Exception\n\nA custom error type thrown when an object does not belong to a category.\n\nFields\n\nmsg::String: A descriptive error message\nobject::Object: The object that does not belong to the category\ncategory::Category: The category that the object should belong to\n\n\n\n\n\n","category":"type"},{"location":"api/#Moma.Categories.MorphismNotInCategoryError","page":"API","title":"Moma.Categories.MorphismNotInCategoryError","text":"MorphismNotInCategoryError <: Exception\n\nA custom error type thrown when a morphism does not belong to a category.\n\nFields\n\nmsg::String: A descriptive error message\nmorphism::Morphism: The morphism that does not belong to the category\ncategory::Category: The category that the morphism should belong to\n\n\n\n\n\n","category":"type"},{"location":"api/#Moma.Categories.MorphismCompositionError","page":"API","title":"Moma.Categories.MorphismCompositionError","text":"MorphismCompositionError <: Exception\n\nA custom error type thrown when attempting to compose incompatible morphisms in a category.\n\nFields\n\nmsg::String: A descriptive error message\nfirst_morphism::Symbol: The identifier of the first morphism\nsecond_morphism::Symbol: The identifier of the second morphism\ntarget::Symbol: The target object of the first morphism\nsource::Symbol: The source object of the second morphism\n\nExamples\n\nobj1 = Object(:A, \"data1\")\nobj2 = Object(:B, \"data2\")\nobj3 = Object(:C, \"data3\")\nm1 = Morphism(obj1, obj2, x -> uppercase(x), :m1)\nm2 = Morphism(obj2, obj3, x -> x * \"!\", :m2)\n# This will throw an error\n@assert try\n        compose(m2, m1)\ncatch e\n        e.msg\nend == \"Morphisms m2 and m1 are not composable, target of m2 C != A source of m1.\"\n\n\n\n\n\n","category":"type"},{"location":"api/#Moma.Categories.PatternHasNoBindingError","page":"API","title":"Moma.Categories.PatternHasNoBindingError","text":"PatternHasNoBindingError <: Exception\n\nA custom error type thrown when a pattern has no binding.\n\n\n\n\n\n","category":"type"},{"location":"api/#Moma.Categories.PatternMustHaveAtLeastOneObject","page":"API","title":"Moma.Categories.PatternMustHaveAtLeastOneObject","text":"PatternMustHaveAtLeastOneObject <: Exception\n\nA custom error type thrown when a pattern has no objects.\n\n\n\n\n\n","category":"type"},{"location":"api/#Functions","page":"API","title":"Functions","text":"","category":"section"},{"location":"api/#Basic-Operations","page":"API","title":"Basic Operations","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Source: src/Categories.jl","category":"page"},{"location":"api/","page":"API","title":"API","text":"Moma.Categories.identity_morphism\nMoma.Categories.compose\nMoma.Categories.is_object_in_category\nMoma.Categories.is_morphism_in_category","category":"page"},{"location":"api/#Moma.Categories.identity_morphism","page":"API","title":"Moma.Categories.identity_morphism","text":"identity_morphism(obj::Object)\n\nCreate an identity morphism for an object.\n\nArguments\n\nobj::Object: The object to create an identity morphism for\n\nReturns\n\nMorphism: A morphism from the object to itself with the identity function\n\nExamples\n\nA = Object(:A, \"data\")\nid_A = identity_morphism(A)\n@assert id_A.map(A.data) == A.data\n\n\n\n\n\n","category":"function"},{"location":"api/#Moma.Categories.compose","page":"API","title":"Moma.Categories.compose","text":"compose(f::Morphism, g::Morphism)\n\nCompose two morphisms if they are composable (target of f equals source of g).\n\nArguments\n\nf::Morphism{S,T}: First morphism\ng::Morphism{T,U}: Second morphism\n\nReturns\n\nMorphism{S,U}: The composition g ∘ f\n\nThrows\n\nErrorException: If the morphisms are not composable (f.target ≠ g.source)\n\nExamples\n\n# Create objects and morphisms\nA = Object(:A, \"hello\")\nB = Object(:B, \"HELLO\")\nC = Object(:C, \"HELLO!\")\nf = Morphism(A, B, uppercase, :f)\ng = Morphism(B, C, s -> s * \"!\", :g)\n\n# Compose morphisms\nh = compose(f, g)\n@assert h.map(\"hello\") == \"HELLO!\"\n\n# This will throw an error\nk = Morphism(C, A, lowercase, :k)\ncompose(f, k)  # Error: Morphisms are not composable\n\n\n\n\n\n","category":"function"},{"location":"api/#Moma.Categories.is_object_in_category","page":"API","title":"Moma.Categories.is_object_in_category","text":"is_object_in_category(obj::Object, cat::Category)\n\nCheck if an object belongs to a category.\n\nArguments\n\nobj::Object: The object to check\ncat::Category: The category to check against\n\n\n\n\n\n","category":"function"},{"location":"api/#Moma.Categories.is_morphism_in_category","page":"API","title":"Moma.Categories.is_morphism_in_category","text":"is_morphism_in_category(morph::Morphism, cat::Category)\n\nCheck if a morphism belongs to a category.\n\nArguments\n\nmorph::Morphism: The morphism to check\ncat::Category: The category to check against\n\nReturns\n\nBool: true if the morphism belongs to the category, false otherwise\n\nExamples\n\n# Check if a morphism belongs to a category\nbelongs = is_morphism_in_category(morph, cat)\n\n\n\n\n\n","category":"function"},{"location":"api/#Pattern-and-Colimit-Operations","page":"API","title":"Pattern and Colimit Operations","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Source: src/Categories.jl","category":"page"},{"location":"api/","page":"API","title":"API","text":"Moma.Categories.create_pattern\nMoma.Categories.check_binding\nMoma.Categories.find_colimit","category":"page"},{"location":"api/#Moma.Categories.create_pattern","page":"API","title":"Moma.Categories.create_pattern","text":"create_pattern(category::Category, objects::Vector{<:Object}, morphisms::Vector{<:Morphism})\n\nCreate a pattern (diagram) from a subset of objects and morphisms in a category.\n\nArguments\n\ncategory::Category: The category containing the objects and morphisms\nobjects::Vector{<:Object}: Objects to include in the pattern\nmorphisms::Vector{<:Morphism}: Morphisms to include in the pattern\n\nReturns\n\nPattern: A new pattern containing the specified objects and morphisms\n\nThrows\n\nErrorException: If any object or morphism does not belong to the category\n\nExamples\n\n# Create objects and morphisms\nA = Object(:A, 1)\nB = Object(:B, 2)\nf = Morphism(A, B, x -> x + 1, :f)\n\n# Create category and pattern\nC = Category([A, B], [f], :C)\nP = create_pattern(C, [A, B], [f])\n\n# This will throw an error\nX = Object(:X, 0)\ncreate_pattern(C, [A, X], [f])  # Error: Objects must belong to the category\n\n\n\n\n\n","category":"function"},{"location":"api/#Moma.Categories.check_binding","page":"API","title":"Moma.Categories.check_binding","text":"check_binding(obj::Object, binding::Dict{<:Object,<:Morphism}, pattern::Pattern)\n\nCheck if an object forms a valid binding for a pattern.\n\nArguments\n\nobj::Object: The object to check as a potential binding\nbinding::Dict{<:Object,<:Morphism}: Current binding of pattern objects to category objects\npattern::Pattern: The pattern to check the binding against\n\nReturns\n\nBool: true if the object forms a valid binding, false otherwise\n\nExamples\n\n# Create a pattern and potential binding\npattern = create_pattern(cat, [obj1, obj2], [morph])\nbinding = Dict(obj1 => obj3, obj2 => obj4)\n\n# Check if obj5 forms a valid binding\nis_valid = check_binding(obj5, binding, pattern)\n\n\n\n\n\n","category":"function"},{"location":"api/#Moma.Categories.find_colimit","page":"API","title":"Moma.Categories.find_colimit","text":"find_colimit(pattern::Pattern)\n\nFind or construct a colimit for a pattern in its category.\n\nArguments\n\npattern::Pattern: The pattern to find a colimit for\n\nReturns\n\nObject: The colimit object if found\nnothing: If no colimit exists\n\nThrows\n\nErrorException: If the pattern is invalid or the colimit cannot be constructed\n\nExamples\n\n# Create a pattern\npattern = create_pattern(cat, [obj1, obj2], [morph])\n\n# Find its colimit\ncolimit = find_colimit(pattern)\n\n\n\n\n\n","category":"function"},{"location":"api/#State-Space-Operations","page":"API","title":"State Space Operations","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Source: src/statespace.jl","category":"page"},{"location":"api/","page":"API","title":"API","text":"Moma.StateSpace.create_ar_model\nMoma.StateSpace.create_var_model\nMoma.StateSpace.create_nonlinear_var_model\nMoma.StateSpace.create_stochastic_nonlinear_var_model\nMoma.StateSpace.simulate_dynamics\nMoma.StateSpace.plot_timeseries\nMoma.StateSpace.get_data\nMoma.StateSpace.get_times\nMoma.StateSpace.extend!\nMoma.StateSpace.collect_timeseries\nMoma.StateSpace.get_links","category":"page"},{"location":"api/#Moma.StateSpace.create_ar_model","page":"API","title":"Moma.StateSpace.create_ar_model","text":"create_ar_model(initial_state::Vector{Float64})\n\nCreate an AR(1) model with the form: xₜ₊₁ = 0.7xₜ + εₜ\n\nArguments\n\ninitial_state::Vector{Float64}: Initial state vector\n\nReturns\n\nTuple{Object{Float64},Object{Vector{Float64}},Morphism,Morphism}: Tuple containing:\nInitial time object\nInitial state object\nTime step morphism\nEvolution morphism\n\nExamples\n\n# Create AR(1) model\ninitial_state = [1.0]\nt₁, s₁, time_step, evolution = create_ar_model(initial_state)\n\n# Simulate the model\nmemory = simulate_dynamics(t₁, s₁, time_step, evolution, 100)\n\n\n\n\n\n","category":"function"},{"location":"api/#Moma.StateSpace.create_var_model","page":"API","title":"Moma.StateSpace.create_var_model","text":"create_var_model(initial_state::Vector{Float64}, A::Matrix{Float64})\n\nCreate a VAR(1) model with the form: xₜ₊₁ = Axₜ + εₜ\n\nArguments\n\ninitial_state::Vector{Float64}: Initial state vector\nA::Matrix{Float64}: Transition matrix\n\nReturns\n\nTuple{Object{Float64},Object{Vector{Float64}},Morphism,Morphism}: Tuple containing:\nInitial time object\nInitial state object\nTime step morphism\nEvolution morphism\n\nExamples\n\n# Create VAR(1) model\ninitial_state = [1.0, 2.0]\nA = [0.7 0.2; 0.1 0.8]\nt₁, s₁, time_step, evolution = create_var_model(initial_state, A)\n\n# Simulate the model\nmemory = simulate_dynamics(t₁, s₁, time_step, evolution, 100)\n\n\n\n\n\n","category":"function"},{"location":"api/#Moma.StateSpace.create_nonlinear_var_model","page":"API","title":"Moma.StateSpace.create_nonlinear_var_model","text":"create_nonlinear_var_model(initial_state::Vector{Float64}, A::Matrix{Float64})\n\nCreate a nonlinear VAR model with the form: xₜ₊₁ = Axₜ + 0.1sin(xₜ) + εₜ\n\nArguments\n\ninitial_state::Vector{Float64}: Initial state vector\nA::Matrix{Float64}: Transition matrix\n\nReturns\n\nTuple{Object{Float64},Object{Vector{Float64}},Morphism,Morphism}: Tuple containing:\nInitial time object\nInitial state object\nTime step morphism\nEvolution morphism\n\nExamples\n\n# Create nonlinear VAR model\ninitial_state = [1.0, 2.0]\nA = [0.7 0.2; 0.1 0.8]\nt₁, s₁, time_step, evolution = create_nonlinear_var_model(initial_state, A)\n\n# Simulate the model\nmemory = simulate_dynamics(t₁, s₁, time_step, evolution, 100)\n\n\n\n\n\n","category":"function"},{"location":"api/#Moma.StateSpace.create_stochastic_nonlinear_var_model","page":"API","title":"Moma.StateSpace.create_stochastic_nonlinear_var_model","text":"create_stochastic_nonlinear_var_model(initial_state::Vector{Float64}, A::Matrix{Float64})\n\nCreate a stochastic nonlinear VAR model with the form: xₜ₊₁ = Axₜ + 0.1sin(xₜ) + 0.1εₜ\n\nArguments\n\ninitial_state::Vector{Float64}: Initial state vector\nA::Matrix{Float64}: Transition matrix\n\nReturns\n\nTuple{Object{Float64},Object{Vector{Float64}},Morphism,Morphism}: Tuple containing:\nInitial time object\nInitial state object\nTime step morphism\nEvolution morphism\n\nExamples\n\n# Create stochastic nonlinear VAR model\ninitial_state = [1.0, 2.0]\nA = [0.7 0.2; 0.1 0.8]\nt₁, s₁, time_step, evolution = create_stochastic_nonlinear_var_model(initial_state, A)\n\n# Simulate the model\nmemory = simulate_dynamics(t₁, s₁, time_step, evolution, 100)\n\n\n\n\n\n","category":"function"},{"location":"api/#Moma.StateSpace.simulate_dynamics","page":"API","title":"Moma.StateSpace.simulate_dynamics","text":"simulate_dynamics(t₁::Object{Float64}, s₁::Object{T}, time_step::Morphism, evolution::Morphism, n_steps::Int)\n\nSimulate the dynamics of a system for a specified number of steps.\n\nArguments\n\nt₁::Object{Float64}: Initial time\ns₁::Object{T}: Initial state\ntime_step::Morphism: Time step morphism\nevolution::Morphism: Evolution morphism\nn_steps::Int: Number of steps to simulate\n\nReturns\n\nTimeSeriesMemory{T}: Memory containing the simulation results\n\nExamples\n\n# Simulate AR(1) model\nt₁, s₁, time_step, evolution = create_ar_model([1.0])\nmemory = simulate_dynamics(t₁, s₁, time_step, evolution, 100)\n\n# Plot results\nplot_timeseries(memory, \"AR(1) Simulation\")\n\n\n\n\n\n","category":"function"},{"location":"api/#Moma.StateSpace.plot_timeseries","page":"API","title":"Moma.StateSpace.plot_timeseries","text":"plot_timeseries(memory::TimeSeriesMemory{T}, title::String=\"Time Series\")\n\nCreate a plot of the time series data.\n\nArguments\n\nmemory::TimeSeriesMemory{T}: The memory to plot\ntitle::String: Title for the plot (default: \"Time Series\")\n\nReturns\n\nPlots.Plot: Plot object showing the time series\n\nExamples\n\n# Plot scalar time series\np = plot_timeseries(memory, \"Scalar Time Series\")\n\n# Plot vector time series (multiple variables)\np = plot_timeseries(memory, \"Vector Time Series\")\n\n\n\n\n\n","category":"function"},{"location":"api/#Moma.StateSpace.get_data","page":"API","title":"Moma.StateSpace.get_data","text":"get_data(memory::TimeSeriesMemory{T})\n\nExtract the state data from memory as a vector of values.\n\nArguments\n\nmemory::TimeSeriesMemory{T}: The memory to extract data from\n\nReturns\n\nVector{T}: Vector of state values\n\nExamples\n\n# Get data from scalar state memory\ndata = get_data(memory)  # Returns Vector{Float64}\n\n# Get data from vector state memory\ndata = get_data(memory)  # Returns Vector{Vector{Float64}}\n\n\n\n\n\n","category":"function"},{"location":"api/#Moma.StateSpace.get_times","page":"API","title":"Moma.StateSpace.get_times","text":"get_times(memory::TimeSeriesMemory{T})\n\nExtract the time points from memory as a vector of values.\n\nArguments\n\nmemory::TimeSeriesMemory{T}: The memory to extract times from\n\nReturns\n\nVector{Float64}: Vector of time values\n\nExamples\n\ntimes = get_times(memory)  # Returns Vector{Float64}\n\n\n\n\n\n","category":"function"},{"location":"api/#Moma.StateSpace.extend!","page":"API","title":"Moma.StateSpace.extend!","text":"extend!(memory::TimeSeriesMemory{T}, new_time::Object{Float64}, new_state::Object{T}, link::Morphism{T,T})\n\nExtend the memory with a new time point, state, and link between states.\n\nArguments\n\nmemory::TimeSeriesMemory{T}: The memory to extend\nnew_time::Object{Float64}: New time point\nnew_state::Object{T}: New state\nlink::Morphism{T,T}: Link between the previous and new state\n\nExamples\n\n# Create initial memory\nt₁ = Object(:t1, 1.0)\ns₁ = Object(:s1, 1.0)\nmemory = TimeSeriesMemory(t₁, s₁)\n\n# Extend with new state\nt₂ = Object(:t2, 2.0)\ns₂ = Object(:s2, 2.0)\nlink = Morphism(s₁, s₂, x -> x + 1, :link)\nextend!(memory, t₂, s₂, link)\n\n\n\n\n\n","category":"function"},{"location":"api/#Moma.StateSpace.collect_timeseries","page":"API","title":"Moma.StateSpace.collect_timeseries","text":"collect_timeseries(memory::TimeSeriesMemory{T})\n\nCollect the time series data from memory.\n\nArguments\n\nmemory::TimeSeriesMemory{T}: The memory to collect data from\n\nReturns\n\nTuple{Vector{Float64},Vector{T}}: Tuple containing (times, states)\n\nExamples\n\ntimes, states = collect_timeseries(memory)\n\n\n\n\n\n","category":"function"},{"location":"api/#Moma.StateSpace.get_links","page":"API","title":"Moma.StateSpace.get_links","text":"get_links(memory::TimeSeriesMemory{T})\n\nGet the links (morphisms) between consecutive states.\n\nArguments\n\nmemory::TimeSeriesMemory{T}: The memory to extract links from\n\nReturns\n\nVector{Morphism{T,T}}: Vector of morphisms representing state transitions\n\nExamples\n\nlinks = get_links(memory)  # Returns Vector{Morphism{T,T}}\n\n\n\n\n\n","category":"function"},{"location":"mes23/#MES25:-A-Mathematical-Framework-for-Enriching-Human-Machine-Interactions","page":"MES25: A Mathematical Framework for Enriching Human-Machine Interactions","title":"MES25: A Mathematical Framework for Enriching Human-Machine Interactions","text":"","category":"section"},{"location":"mes23/#Overview","page":"MES25: A Mathematical Framework for Enriching Human-Machine Interactions","title":"Overview","text":"","category":"section"},{"location":"mes23/","page":"MES25: A Mathematical Framework for Enriching Human-Machine Interactions","title":"MES25: A Mathematical Framework for Enriching Human-Machine Interactions","text":"This paper presents a conceptual mathematical framework for developing rich human-machine interactions to improve decision-making in social organizations. It introduces the concept of a \"multi-level artificial cognitive system\" called a data analyser (DA) that collaborates with humans in data analysis and decision-making processes.","category":"page"},{"location":"mes23/#Key-Concepts","page":"MES25: A Mathematical Framework for Enriching Human-Machine Interactions","title":"Key Concepts","text":"","category":"section"},{"location":"mes23/#Data-Analyser-(DA)","page":"MES25: A Mathematical Framework for Enriching Human-Machine Interactions","title":"Data Analyser (DA)","text":"","category":"section"},{"location":"mes23/","page":"MES25: A Mathematical Framework for Enriching Human-Machine Interactions","title":"MES25: A Mathematical Framework for Enriching Human-Machine Interactions","text":"The DA is designed to:","category":"page"},{"location":"mes23/","page":"MES25: A Mathematical Framework for Enriching Human-Machine Interactions","title":"MES25: A Mathematical Framework for Enriching Human-Machine Interactions","text":"Collect and analyze data\nLearn and develop autonomous procedures\nAnticipate situations\nDevelop new responses\nImprove decision-making processes","category":"page"},{"location":"mes23/#Human-Machine-Partnership","page":"MES25: A Mathematical Framework for Enriching Human-Machine Interactions","title":"Human-Machine Partnership","text":"","category":"section"},{"location":"mes23/","page":"MES25: A Mathematical Framework for Enriching Human-Machine Interactions","title":"MES25: A Mathematical Framework for Enriching Human-Machine Interactions","text":"The framework focuses on:","category":"page"},{"location":"mes23/","page":"MES25: A Mathematical Framework for Enriching Human-Machine Interactions","title":"MES25: A Mathematical Framework for Enriching Human-Machine Interactions","text":"Collaborative data analysis\nKnowledge extension\nAutonomous learning\nCreation of new procedures\nDeep anticipation capabilities","category":"page"},{"location":"mes23/#Memory-Evolutive-Systems-Integration","page":"MES25: A Mathematical Framework for Enriching Human-Machine Interactions","title":"Memory Evolutive Systems Integration","text":"","category":"section"},{"location":"mes23/","page":"MES25: A Mathematical Framework for Enriching Human-Machine Interactions","title":"MES25: A Mathematical Framework for Enriching Human-Machine Interactions","text":"The paper uses MES to describe:","category":"page"},{"location":"mes23/","page":"MES25: A Mathematical Framework for Enriching Human-Machine Interactions","title":"MES25: A Mathematical Framework for Enriching Human-Machine Interactions","text":"Social organization operations\nDA construction and evolution\nMulti-scale system interactions\nMulti-agent coordination\nMulti-temporality handling","category":"page"},{"location":"mes23/#Technical-Framework","page":"MES25: A Mathematical Framework for Enriching Human-Machine Interactions","title":"Technical Framework","text":"","category":"section"},{"location":"mes23/#AI-Integration","page":"MES25: A Mathematical Framework for Enriching Human-Machine Interactions","title":"AI Integration","text":"","category":"section"},{"location":"mes23/","page":"MES25: A Mathematical Framework for Enriching Human-Machine Interactions","title":"MES25: A Mathematical Framework for Enriching Human-Machine Interactions","text":"The paper discusses:","category":"page"},{"location":"mes23/","page":"MES25: A Mathematical Framework for Enriching Human-Machine Interactions","title":"MES25: A Mathematical Framework for Enriching Human-Machine Interactions","text":"Historical AI development\nSymbolic AI approaches\nConnectionist paradigms\nIntegration of multiple AI paradigms\nCategory theory applications","category":"page"},{"location":"mes23/#Implementation-Aspects","page":"MES25: A Mathematical Framework for Enriching Human-Machine Interactions","title":"Implementation Aspects","text":"","category":"section"},{"location":"mes23/","page":"MES25: A Mathematical Framework for Enriching Human-Machine Interactions","title":"MES25: A Mathematical Framework for Enriching Human-Machine Interactions","text":"Key implementation features:","category":"page"},{"location":"mes23/","page":"MES25: A Mathematical Framework for Enriching Human-Machine Interactions","title":"MES25: A Mathematical Framework for Enriching Human-Machine Interactions","text":"Multi-level cognitive systems\nRich human-machine interactions\nAnticipatory capabilities\nRisk prevention strategies\nOpportunity identification","category":"page"},{"location":"mes23/#Applications","page":"MES25: A Mathematical Framework for Enriching Human-Machine Interactions","title":"Applications","text":"","category":"section"},{"location":"mes23/#Healthcare-Example","page":"MES25: A Mathematical Framework for Enriching Human-Machine Interactions","title":"Healthcare Example","text":"","category":"section"},{"location":"mes23/","page":"MES25: A Mathematical Framework for Enriching Human-Machine Interactions","title":"MES25: A Mathematical Framework for Enriching Human-Machine Interactions","text":"Demonstrates DA implementation in:","category":"page"},{"location":"mes23/","page":"MES25: A Mathematical Framework for Enriching Human-Machine Interactions","title":"MES25: A Mathematical Framework for Enriching Human-Machine Interactions","text":"Symptom detection\nAutonomous response selection\nDecision-making participation\nCommunication improvement\nMisunderstanding detection","category":"page"},{"location":"mes23/#General-Applications","page":"MES25: A Mathematical Framework for Enriching Human-Machine Interactions","title":"General Applications","text":"","category":"section"},{"location":"mes23/","page":"MES25: A Mathematical Framework for Enriching Human-Machine Interactions","title":"MES25: A Mathematical Framework for Enriching Human-Machine Interactions","text":"The framework can be applied to:","category":"page"},{"location":"mes23/","page":"MES25: A Mathematical Framework for Enriching Human-Machine Interactions","title":"MES25: A Mathematical Framework for Enriching Human-Machine Interactions","text":"Social organizations\nHealthcare institutions\nEducational systems\nBusiness environments\nComplex decision-making scenarios","category":"page"},{"location":"mes23/#Future-Directions","page":"MES25: A Mathematical Framework for Enriching Human-Machine Interactions","title":"Future Directions","text":"","category":"section"},{"location":"mes23/","page":"MES25: A Mathematical Framework for Enriching Human-Machine Interactions","title":"MES25: A Mathematical Framework for Enriching Human-Machine Interactions","text":"The paper suggests development paths for:","category":"page"},{"location":"mes23/","page":"MES25: A Mathematical Framework for Enriching Human-Machine Interactions","title":"MES25: A Mathematical Framework for Enriching Human-Machine Interactions","text":"Third-generation AI systems\nEnhanced human-machine collaboration\nImproved anticipatory capabilities\nRisk prevention mechanisms\nDecision-making optimization ","category":"page"},{"location":"moma25/#MoMa25:-Monetary-Macro-Accounting-Theory","page":"MoMa25: Monetary Macro Accounting Theory","title":"MoMa25: Monetary Macro Accounting Theory","text":"","category":"section"},{"location":"moma25/#Overview","page":"MoMa25: Monetary Macro Accounting Theory","title":"Overview","text":"","category":"section"},{"location":"moma25/","page":"MoMa25: Monetary Macro Accounting Theory","title":"MoMa25: Monetary Macro Accounting Theory","text":"This paper develops a specification for software for macro accounting (MoMa) and a monetary macro accounting theory (MoMaT). It presents a novel approach where money functions as a medium of payment for obligations and debts, rather than just a medium of exchange.","category":"page"},{"location":"moma25/#Key-Concepts","page":"MoMa25: Monetary Macro Accounting Theory","title":"Key Concepts","text":"","category":"section"},{"location":"moma25/#Theoretical-Framework","page":"MoMa25: Monetary Macro Accounting Theory","title":"Theoretical Framework","text":"","category":"section"},{"location":"moma25/","page":"MoMa25: Monetary Macro Accounting Theory","title":"MoMa25: Monetary Macro Accounting Theory","text":"The paper addresses:","category":"page"},{"location":"moma25/","page":"MoMa25: Monetary Macro Accounting Theory","title":"MoMa25: Monetary Macro Accounting Theory","text":"Temporal misalignment in production\nLegal principles of Separation and Abstraction\nDebt, contracts, and property rights\nMulti-level monetary systems analysis","category":"page"},{"location":"moma25/#System-Levels","page":"MoMa25: Monetary Macro Accounting Theory","title":"System Levels","text":"","category":"section"},{"location":"moma25/","page":"MoMa25: Monetary Macro Accounting Theory","title":"MoMa25: Monetary Macro Accounting Theory","text":"The monetary system operates at three interconnected levels:","category":"page"},{"location":"moma25/","page":"MoMa25: Monetary Macro Accounting Theory","title":"MoMa25: Monetary Macro Accounting Theory","text":"Micro Level: Division of labor facilitation\nMeso Level: Risk sharing in banking\nMacro Level: GDP distribution through issued money","category":"page"},{"location":"moma25/#Core-Components","page":"MoMa25: Monetary Macro Accounting Theory","title":"Core Components","text":"","category":"section"},{"location":"moma25/#Bill-of-Exchange-(BoE)","page":"MoMa25: Monetary Macro Accounting Theory","title":"Bill of Exchange (BoE)","text":"","category":"section"},{"location":"moma25/","page":"MoMa25: Monetary Macro Accounting Theory","title":"MoMa25: Monetary Macro Accounting Theory","text":"Serves as:","category":"page"},{"location":"moma25/","page":"MoMa25: Monetary Macro Accounting Theory","title":"MoMa25: Monetary Macro Accounting Theory","text":"Unifying instrument\nBridge between debt processes\nMoney issuing mechanism\nConnection between fiat and gold-based systems","category":"page"},{"location":"moma25/#Mathematical-Foundations","page":"MoMa25: Monetary Macro Accounting Theory","title":"Mathematical Foundations","text":"","category":"section"},{"location":"moma25/","page":"MoMa25: Monetary Macro Accounting Theory","title":"MoMa25: Monetary Macro Accounting Theory","text":"Utilizes:","category":"page"},{"location":"moma25/","page":"MoMa25: Monetary Macro Accounting Theory","title":"MoMa25: Monetary Macro Accounting Theory","text":"Sheaf theory for accounting invariances\nHomology theory for monetary policy\nOpen Games for computation\nMulti-agent model analysis","category":"page"},{"location":"moma25/#Applications","page":"MoMa25: Monetary Macro Accounting Theory","title":"Applications","text":"","category":"section"},{"location":"moma25/#Supply-Chain-Finance","page":"MoMa25: Monetary Macro Accounting Theory","title":"Supply Chain Finance","text":"","category":"section"},{"location":"moma25/","page":"MoMa25: Monetary Macro Accounting Theory","title":"MoMa25: Monetary Macro Accounting Theory","text":"Debt networks analysis\nPayment systems integration\nRisk distribution mechanisms\nFinancial obligation tracking","category":"page"},{"location":"moma25/#Monetary-Policy","page":"MoMa25: Monetary Macro Accounting Theory","title":"Monetary Policy","text":"","category":"section"},{"location":"moma25/","page":"MoMa25: Monetary Macro Accounting Theory","title":"MoMa25: Monetary Macro Accounting Theory","text":"Central banking operations\nMoney circulation analysis\nDebt vortices study\nFinancial obligation resolution","category":"page"},{"location":"moma25/#Technical-Implementation","page":"MoMa25: Monetary Macro Accounting Theory","title":"Technical Implementation","text":"","category":"section"},{"location":"moma25/#Software-Components","page":"MoMa25: Monetary Macro Accounting Theory","title":"Software Components","text":"","category":"section"},{"location":"moma25/","page":"MoMa25: Monetary Macro Accounting Theory","title":"MoMa25: Monetary Macro Accounting Theory","text":"MoMa implementation can include:","category":"page"},{"location":"moma25/","page":"MoMa25: Monetary Macro Accounting Theory","title":"MoMa25: Monetary Macro Accounting Theory","text":"Macro accounting systems\nSmart contracts\nStructural econometric models\nData analysis tools","category":"page"},{"location":"moma25/#Mathematical-Tools","page":"MoMa25: Monetary Macro Accounting Theory","title":"Mathematical Tools","text":"","category":"section"},{"location":"moma25/","page":"MoMa25: Monetary Macro Accounting Theory","title":"MoMa25: Monetary Macro Accounting Theory","text":"Proposes:","category":"page"},{"location":"moma25/","page":"MoMa25: Monetary Macro Accounting Theory","title":"MoMa25: Monetary Macro Accounting Theory","text":"Category theory\nSheaf theory like MES colimits\nHomology theory like MES coregulators\nGame theory","category":"page"},{"location":"moma25/#Future-Implications","page":"MoMa25: Monetary Macro Accounting Theory","title":"Future Implications","text":"","category":"section"},{"location":"moma25/","page":"MoMa25: Monetary Macro Accounting Theory","title":"MoMa25: Monetary Macro Accounting Theory","text":"The framework provides foundations for:","category":"page"},{"location":"moma25/","page":"MoMa25: Monetary Macro Accounting Theory","title":"MoMa25: Monetary Macro Accounting Theory","text":"Macro economic research in monetary systems\nDigital currency development, like stable coins\nReal estate management \nRenewable energy management systems, virtual power plants\nEconomic policy making ","category":"page"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"This section provides practical examples of using the Moma package for various applications.","category":"page"},{"location":"examples/#Geometric-System","page":"Examples","title":"Geometric System","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"more...","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Implementation with custom data types (Point, Line)\nStructured representation of geometric objects and transformations\nComposition of geometric transformations using morphisms\nPossible extensions\nPreservation of geometric invariants through categorical framework\nPattern recognition in geometric structures\nHierarchical organization of complex geometric systems\nCategory and pattern construction for geometric configurations","category":"page"},{"location":"examples/#Error-Handling","page":"Examples","title":"Error Handling","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"...more","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Comprehensive error checking for categorical laws\nEdge case handling and validation\nBest practices for robust error management\nPossible extensions:\nSelf-healing systems based on MES concepts\nHierarchical error handling with different time scales\nCo-regulator pattern for specialized error handling\nMemory-based recovery using system links","category":"page"},{"location":"papers/#Papers","page":"Papers","title":"Papers","text":"","category":"section"},{"location":"papers/","page":"Papers","title":"Papers","text":"This section provides an overview of the papers that form the theoretical foundation of the MoMa package.","category":"page"},{"location":"papers/#MoMa25:-Monetary-Macro-Accounting","page":"Papers","title":"MoMa25: Monetary Macro Accounting","text":"","category":"section"},{"location":"papers/","page":"Papers","title":"Papers","text":"Summary, pdf","category":"page"},{"location":"papers/","page":"Papers","title":"Papers","text":"MoMa25 develops a specification for software for macro accounting (MoMa) and a monetary macro accounting theory (MoMaT). The paper presents a novel approach where money functions as a medium of payment for obligations and debts, rather than just a medium of exchange. It addresses temporal misalignment in production, legal principles of Separation and Abstraction, and debt management through a three-level system: micro (division of labor), meso (banking risk sharing), and macro (GDP distribution). The paper proposes and argues why to use mathematical tools including sheaf theory for accounting invariances, homology theory for monetary policy, and open games for computation, with applications in supply chain finance, monetary policy, renewable energy models, or digital currency development.","category":"page"},{"location":"papers/","page":"Papers","title":"Papers","text":"A MoMa Simulation in Julia of a National Accounting is in src/original_moma directory contains several files used for generating and checking simulation data underlying the MoMa paper. In file momascf_v02_en.jl is a simulation of the following basic MoMa macro accounting structure.","category":"page"},{"location":"papers/","page":"Papers","title":"Papers","text":"(Image: Basic National Accounting Structure) ","category":"page"},{"location":"papers/","page":"Papers","title":"Papers","text":"These macro accounting bookings generate such dynamics:","category":"page"},{"location":"papers/","page":"Papers","title":"Papers","text":"(Image: Basic National Accounting Dynamics) ","category":"page"},{"location":"papers/#MES23:-Human–Machine-Interactions","page":"Papers","title":"MES23: Human–Machine Interactions","text":"","category":"section"},{"location":"papers/","page":"Papers","title":"Papers","text":"Summary, pdf","category":"page"},{"location":"papers/","page":"Papers","title":"Papers","text":"MES23 applies the Memory Evolutive Systems framework to analyze human-machine interactions in complex systems. The paper explores how multiple agents with different temporalities can cooperate effectively, focusing on the synchronization and coordination challenges that arise in human-machine systems. It provides insights into designing more effective collaborative systems where humans and machines work together, taking into account their different processing speeds and decision-making capabilities.","category":"page"},{"location":"papers/#MES07:-Memory-Evolutive-Systems","page":"Papers","title":"MES07: Memory Evolutive Systems","text":"","category":"section"},{"location":"papers/","page":"Papers","title":"Papers","text":"Summary, pdf","category":"page"},{"location":"papers/","page":"Papers","title":"Papers","text":"MES07 presents a comprehensive mathematical framework for modeling complex evolutionary systems using category theory. The paper introduces Memory Evolutive Systems (MES) as a theoretical foundation for understanding how biological, cognitive, and social systems develop and adapt over time. It explains how multiple hierarchical components interact and evolve, incorporating concepts such as emergence, complexity, and time-scaling. The framework is particularly valuable for modeling systems with multiple interconnected levels of organization, memory formation, and adaptive behavior.","category":"page"},{"location":"papers/","page":"Papers","title":"Papers","text":"A comprehensive synthesis of two decades of research on memory evolutive systems, presenting mathematical models for autonomous evolutionary systems such as biological, social, and nervous systems.","category":"page"},{"location":"#Central-Banks-for-All-and-Everything","page":"Home","title":"Central Banks for All and Everything","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This Julia package implements a Monetary Macro Accounting (MoMa) system of Menéndez and Winschel. It is modeled with categorical tools of Memory Evolutive Systems (MES) of Ehresmann and Vanbremeersch. By that we can model multi-level, hierarchical systems like micro, meso and macro economies are.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The monetary theory of MoMa works for national accounting, sectors and companies but applies also for within companies like holdings with subsidiaries and down to smaller levels like to processes of a box ordering screws. MoMa theory is a multi-level accounting theory for macro accounting with different time scales extending micro accounting aka double-entry bookkeeping.  This can be thought of concepts of composable enterprises for a new generation of ERP (Enterpsice Resource Planing)  systems, then EcRP systems for economic resource planing.","category":"page"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This documentation contain implementations and","category":"page"},{"location":"","page":"Home","title":"Home","text":"Basic category theoretical constructions\nA statespace model implementation with categorical and MES tools\nBasic simulation of a MoMa national accounting\nSummaries and pdfs of MES and MoMa","category":"page"},{"location":"#Documentation-Sections","page":"Home","title":"Documentation Sections","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Categories: Introduction to category theory concepts\nState Space Models: Implementation of state space models using MES\nExamples: Usage examples and tutorials\nPapers: Related academic papers and references\nAPI: Detailed API documentation","category":"page"},{"location":"#Quick-Start","page":"Home","title":"Quick Start","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using Moma\n\n# Create objects and morphisms\nA = Object(:A, \"data\")\nB = Object(:B, \"DATA\")\nf = Morphism(A, B, uppercase, :f)\n\n# Create a category\nC = Category([A, B], [f], :C)\n\n# Create and simulate a state space model\nt₁, s₁, time_step, evolution = create_ar_model([0.5])\nmemory = simulate_dynamics(t₁, s₁, time_step, evolution, 100)","category":"page"},{"location":"#Contributing","page":"Home","title":"Contributing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Contributions are welcome! by email to repository owner","category":"page"}]
}
